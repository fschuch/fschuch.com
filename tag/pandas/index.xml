<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pandas | F. Schuch</title><link>https://www.fschuch.com/tag/pandas/</link><atom:link href="https://www.fschuch.com/tag/pandas/index.xml" rel="self" type="application/rss+xml"/><description>Pandas</description><generator>Wowchemy (https://wowchemy.com)</generator><language>pt-br</language><copyright>© 2020-2025 Felipe N. Schuch</copyright><lastBuildDate>Fri, 22 Jan 2021 00:00:00 +0000</lastBuildDate><image><url>https://www.fschuch.com/media/icon_hu25d0b20bf2bf90ac27c6cbd6ce22358d_22074_512x512_fill_lanczos_center_2.png</url><title>Pandas</title><link>https://www.fschuch.com/tag/pandas/</link></image><item><title>Jupyter Notebook como uma Poderosa Ferramenta Educacional</title><link>https://www.fschuch.com/blog/2021/01/22/jupyter-notebook-como-uma-poderosa-ferramenta-educacional/</link><pubDate>Fri, 22 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.fschuch.com/blog/2021/01/22/jupyter-notebook-como-uma-poderosa-ferramenta-educacional/</guid><description>&lt;details class="toc-inpage d-print-none " open>
&lt;summary class="font-weight-bold">Lista de Conteúdos&lt;/summary>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>&lt;a href="#introdução">Introdução&lt;/a>&lt;/li>
&lt;li>&lt;a href="#o-que-é-um-jupyter-notebook">O que é um Jupyter Notebook?&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#formas-de-acessarcompartilhar">Formas de Acessar/Compartilhar&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#conceitos-pedagógicos">Conceitos Pedagógicos&lt;/a>&lt;/li>
&lt;li>&lt;a href="#curva-de-progressão">Curva de Progressão&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#nível-inicial">Nível Inicial&lt;/a>&lt;/li>
&lt;li>&lt;a href="#nível-intermediário">Nível Intermediário&lt;/a>&lt;/li>
&lt;li>&lt;a href="#nível-avançado">Nível Avançado&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#leitura-recomendada">Leitura Recomendada&lt;/a>&lt;/li>
&lt;li>&lt;a href="#exemplos">Exemplos&lt;/a>&lt;/li>
&lt;li>&lt;a href="#conclusão">Conclusão&lt;/a>&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;/details>
&lt;h2 id="introdução">Introdução&lt;/h2>
&lt;p>O ambiente Jupyter Notebook vem se consolidando como principal ferramenta de trabalho em Ciência de Dados, Aprendizado de Máquina e Inteligência Artificial.
Muitas das características que o tornam tão popular nessas áreas também o colocam em uma posição de &lt;strong>destaque para o campo educacional&lt;/strong>.
As opções mais intuitivas seriam no ensino de engenharia ou ciência exatas em geral, mas não se engane, qualquer atividade que envolva o trabalho com dados pode se beneficiar, incluindo as ciências da saúde e as ciências humanas.&lt;/p>
&lt;p>Esse post apresenta uma contextualização sobre o &lt;a href="https://jupyter.org/" target="_blank" rel="noopener">Projeto Jupyter&lt;/a>, uma explanação sobre a utilidade da ferramenta no cenário pedagógico, além da exemplificação de como se pode avançar progressivamente ao combinar Jupyter com diversas outras ferramentas do universo Python, para tornar a experiência mais agradável tanto para docentes quanto para estudantes. Ao final, apresenta-se a leitura recomendada e exemplos de aplicação.&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
Essa própria postagem foi produzida a partir de um Jupyter Notebook, assim como muitas outras nesse blog, mostrando a flexibilidade da ferramenta para a produção de conteúdo em geral.
&lt;/div>
&lt;/div>
&lt;!--adsense-->
&lt;h2 id="o-que-é-um-jupyter-notebook">O que é um Jupyter Notebook?&lt;/h2>
&lt;p>O &lt;a href="https://jupyter.org/" target="_blank" rel="noopener">Projeto Jupyter&lt;/a> foi fundado em 2015, sendo uma organização sem fins lucrativos que visa desenvolver software aberto e serviços para computação interativa. A denominação do projeto é uma referências às três principais linguagens de programação suportadas por ele, &lt;a href="https://julialang.org/" target="_blank" rel="noopener">Julia&lt;/a>, &lt;a href="https://www.python.org/" target="_blank" rel="noopener">Python&lt;/a> e &lt;a href="https://www.r-project.org/" target="_blank" rel="noopener">R&lt;/a> (&lt;a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels" target="_blank" rel="noopener">veja todas as linguagens suportadas aqui&lt;/a>), e também uma homenagem aos cadernos onde &lt;a href="https://pt.wikipedia.org/wiki/Galileu_Galilei" target="_blank" rel="noopener">Galileu Galilei&lt;/a> tomava nota de suas descobertas sobre as luas de Júpiter.&lt;/p>
&lt;p>O Jupyter Notebook é uma das peças do projeto, compreendendo o software no qual se pode criar os cadernos de anotações Jupyter (&lt;em>Jupyter notebooks&lt;/em>), que por sua vez são constituídos por um ambiente de programação que &lt;strong>mistura blocos de código executável, visualizações e texto enriquecido&lt;/strong> com equações, figuras, animações, tabelas, links que redirecionem para recursos externos, títulos e subtítulos, listas e muitos outros recursos.
Essa flexibilidade permite ao usuário unir código, dados e narrativa, para construir uma verdadeira &lt;strong>história computacional e interativa&lt;/strong>.
É possível executar o código, ver o que acontece, modificar e repetir, onde o usuário tem uma &lt;em>conversa&lt;/em> com os dados que está analisando.
Veja o exemplo a seguir:&lt;/p>
&lt;figure id="figure-exemplo-de-um-jupyter-notebook-começando-por-um-bloco-de-texto-em-markdown-contendo-um-título-explicações-e-uma-equação-renderizada-com-latexhttpswwwlatex-projectorg-três-blocos-de-código-produzem-o-gráfico-final-fonte-adaptado-de-la-barba-et-al-2019httpsjupyter4edugithubiojupyter-edu-book">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >
&lt;img alt="Exemplo de um Jupyter Notebook, começando por um bloco de texto em markdown contendo um título, explicações e uma equação renderizada com [LaTeX](https://www.latex-project.org/). Três blocos de código produzem o gráfico final. Fonte: Adaptado de [L.A. Barba et al. (2019)](https://jupyter4edu.github.io/jupyter-edu-book/)." srcset="
/blog/2021/01/22/jupyter-notebook-como-uma-poderosa-ferramenta-educacional/figure_hu23f249effb7277f4d44bfabb20b1d620_223359_7372e6c61fb2e044be1f0e827e8ffddc.jpg 400w,
/blog/2021/01/22/jupyter-notebook-como-uma-poderosa-ferramenta-educacional/figure_hu23f249effb7277f4d44bfabb20b1d620_223359_82b292b2cde02e606bb43f91bff88d13.jpg 760w,
/blog/2021/01/22/jupyter-notebook-como-uma-poderosa-ferramenta-educacional/figure_hu23f249effb7277f4d44bfabb20b1d620_223359_1200x1200_fit_q90_lanczos.jpg 1200w"
src="https://www.fschuch.com/blog/2021/01/22/jupyter-notebook-como-uma-poderosa-ferramenta-educacional/figure_hu23f249effb7277f4d44bfabb20b1d620_223359_7372e6c61fb2e044be1f0e827e8ffddc.jpg"
width="760"
height="488"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Exemplo de um Jupyter Notebook, começando por um bloco de texto em markdown contendo um título, explicações e uma equação renderizada com &lt;a href="https://www.latex-project.org/">LaTeX&lt;/a>. Três blocos de código produzem o gráfico final. Fonte: Adaptado de &lt;a href="https://jupyter4edu.github.io/jupyter-edu-book/">L.A. Barba et al. (2019)&lt;/a>.
&lt;/figcaption>&lt;/figure>
&lt;p>Além disso, &lt;strong>Jupyter é uma ferramenta grátis e de código aberto&lt;/strong>. Está disponível para os principais sistemas operacionais do mercado e também por serviços remotos na nuvem, onde apenas o acesso a um navegador de internet é o suficiente para utilizar a ferramenta. Esse é um ponto importante frente à outras alternativas de software proprietário, que os alunos muitas vezes sequer conseguem ter acesso fora das instituições de ensino.&lt;/p>
&lt;h3 id="formas-de-acessarcompartilhar">Formas de Acessar/Compartilhar&lt;/h3>
&lt;p>A maneira mais simples de testar o Jupyter é por meio &lt;a href="https://colab.research.google.com/" target="_blank" rel="noopener">Colaboratory&lt;/a>, ou simplesmente &lt;em>Colab&lt;/em>, um serviço Google que permite a criação, colaboração e compartilhamento de Notebooks inteiramente na nuvem.&lt;/p>
&lt;p>Outra opção é o &lt;a href="https://mybinder.org/" target="_blank" rel="noopener">Binder&lt;/a>, serviço na nuvem que permite construir ambientes personalizados e lançar um servidor Jupyter na nuvem a partir de um repositório do GitHub. Além disso, o site apresenta um tutorial de como utilizar o Jupyter em Julia, Python e R.&lt;/p>
&lt;p>Para instalação local em sua máquina, o Jupyter já acompanha as principais instalações do &lt;a href="https://www.anaconda.com/" target="_blank" rel="noopener">Anaconda&lt;/a>, um gerenciador de pacotes Python. Caso já tenha Anaconda instalado mas não o Jupyter, basta utilizar o comando:&lt;/p>
&lt;pre>&lt;code class="language-bash">conda install -c conda-forge jupyterlab
&lt;/code>&lt;/pre>
&lt;p>Outra possibilidade é o gerenciar de pacotes Python &lt;a href="https://pypi.org/project/pip/" target="_blank" rel="noopener">pip&lt;/a>, com o comando:&lt;/p>
&lt;pre>&lt;code class="language-bash">pip install jupyterlab
&lt;/code>&lt;/pre>
&lt;p>Por fim, o &lt;a href="https://jupyter.org/hub" target="_blank" rel="noopener">JupyterHub&lt;/a> disponibiliza o poder de Jupyter para um grupo de usuários (estudantes de um curso ou um grupo de pesquisa, por exemplo), gerenciando ambientes virtuais e recursos computacionais.&lt;/p>
&lt;p>Os Jupyter notebooks podem ser exportados em diversos formatos, dependendo do meio onde serão distribuídos. O arquivo &lt;code>.ipynb&lt;/code> é o notebook em sua essência, possibilitando aos demais executar e interagir com o seu conteúdo.
É possível exportar como PDF, para impressão e compartilhamento, Markdown ou HTML para visualização web (como esse post), LaTeX para inclusão em material técnico/científico e até mesmo para apresentação de slides.&lt;/p>
&lt;h2 id="conceitos-pedagógicos">Conceitos Pedagógicos&lt;/h2>
&lt;p>Como vimos anteriormente, a mistura entre blocos de código executáveis e blocos de texto enriquecido permitem ao Jupyter e seus usuários algo como combinar as explicações tradicionalmente encontrada nos livros com a interatividade de um aplicativo web.
E com isso, Jupyter pode ter seu papel de destaque também como ferramenta educacional.
Por ser tão flexível, se enquadra não apenas em áreas do conhecimento onde a programação é um objetivo final, mas também em áreas onde &lt;strong>a programação se apresenta como um meio para analisar e resolver problemas&lt;/strong>.&lt;/p>
&lt;p>A aplicação de Jupyter no ensino pode se dar nos mais &lt;strong>diversos formatos&lt;/strong>, a depender das necessidades do curso, e do conforto/interesse do instrutor para elaborar o material.
Jupyter pode compreender apenas parte de uma aula, ou um curso inteiro. Pode ser utilizado para produzir a apostila que o turma deverá seguir durante o curso, o material de apoio, leitura complementar, listas de exercícios, exercícios resolvidos ou o gabarito de atividades avaliativas.
Pode ser apresentado e encorajado como um formato no qual os alunos possam realizar e entregar o dever de casa e atividades avaliativas.
Podem ser exibidos durante uma aula demonstrativa, presencial ou online, ou convidar os alunos a interagir com o conteúdo durante uma aula prática em laboratório.
&lt;strong>O objetivo é instigar o aprendizado ativo&lt;/strong>, aumentando o engajamento, participação, entendimento, desempenho e a preparação para a carreira futura dos alunos.
É exercitada a criatividade, raciocínio lógico, capacidade de resolver problemas, comunicação e outras habilidades que são indispensáveis para qualquer área de atuação.&lt;/p>
&lt;h2 id="curva-de-progressão">Curva de Progressão&lt;/h2>
&lt;p>Esta seção apresenta uma descrição (não exaustiva) da curva de aprendizado para alunos e instrutores, exemplificada com programação em Python e suas principais bibliotecas de uso geral.&lt;/p>
&lt;p>Mas antes de começar, vale mencionar que o nível zero é dominar as denominadas células &lt;em>Markdown&lt;/em>, para texto enriquecido. Nelas, é possível inserir equações com sintaxe $\LaTeX$:&lt;/p>
&lt;p>$$E = mc^2,$$&lt;/p>
&lt;p>títulos e subtítulos, texto em &lt;strong>destaque&lt;/strong> e &lt;em>itálico&lt;/em>. Temos também listas:&lt;/p>
&lt;ul>
&lt;li>Item 1&lt;/li>
&lt;li>Item 2&lt;/li>
&lt;li>Item 3&lt;/li>
&lt;/ul>
&lt;p>Citações:&lt;/p>
&lt;blockquote>
&lt;p>Considere usar Jupyter na sua instituição de ensino (2021, F. N. Schuch).&lt;/p>
&lt;/blockquote>
&lt;p>Além de código com destaque de sintaxe, lista de tarefas, tabelas, figuras, vídeos, links e muito mais (&lt;a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="noopener">veja mais detalhes aqui&lt;/a>).&lt;/p>
&lt;h3 id="nível-inicial">Nível Inicial&lt;/h3>
&lt;p>Uma vez que sabemos como adicionar blocos explicativos detalhados, o próximo passo é trabalhar com blocos de código. Vamos tomar como exemplo o caso do movimento uniformemente variável, onde a posição de um dado objeto no espaço em função do tempo é dado pela seguinte equação:&lt;/p>
&lt;p>$$ S(t) = S_0 + v_0t + \dfrac{at^2}{2}, $$&lt;/p>
&lt;p>onde $S$ é a posição, $S_0$ a posição inicial, $v_0$ é a velocidade inicial, $a$ a aceleração e $t$ o tempo.&lt;/p>
&lt;p>Digamos que a aula não seja de programação, mas mesmo assim, a turma pode ser convidada a interagir com o problema e testar diferentes respostas ao alterar os parâmetros quando o seguinte bloco de código é fornecido:&lt;/p>
&lt;pre>&lt;code class="language-Python"># Atribuímos os parâmetros do problema
S0 = 0
v0 = 10
a = -1
t = 10
# A equação que descreve o problema
S = S0 + v0 * t + (a * t ** 2) / 2
# Por fim, exibimos a resposta
print(S)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-text">50.0
&lt;/code>&lt;/pre>
&lt;p>Essa situação pode se aplicar nas mais diversas disciplinas que envolvam algum tipo de cálculo, análise de dados e/ou tomada de decisão.
Ou dependendo do objetivo do material, o bloco de código pode estar em vazio, servindo como um convite para que a turma resolva o problema por meio de ferramentas computacionais com uma barreira de entrada mínima.&lt;/p>
&lt;h3 id="nível-intermediário">Nível Intermediário&lt;/h3>
&lt;p>Como próximo passo, pode-se incluir mais aspectos de lógica de programação, como: &lt;a href="https://docs.python.org/pt-br/3/tutorial/controlflow.html#for-statements" target="_blank" rel="noopener">laços&lt;/a>, &lt;a href="https://docs.python.org/pt-br/3/tutorial/controlflow.html#if-statements" target="_blank" rel="noopener">testes lógicos&lt;/a>, &lt;a href="https://docs.python.org/pt-br/3/tutorial/inputoutput.html" target="_blank" rel="noopener">entrada e saída de arquivos&lt;/a>, &lt;a href="https://docs.python.org/pt-br/3/tutorial/controlflow.html#defining-functions" target="_blank" rel="noopener">funções&lt;/a>, &lt;a href="https://docs.python.org/pt-br/3/tutorial/errors.html" target="_blank" rel="noopener">controle de erros e exceções&lt;/a> e a manipulação de &lt;a href="%28https://docs.python.org/pt-br/3/tutorial/datastructures.html%29">estruturas de dados&lt;/a>.&lt;/p>
&lt;p>Outro ponto chave é a utilização de ferramentas mais sofisticadas para álgebra matricial, produção de gráficos, álgebra analítica e métodos numéricos. Quatro exemplos são incluídos a seguir.&lt;/p>
&lt;h4 id="numpy">Numpy&lt;/h4>
&lt;p>&lt;a href="https://numpy.org/" target="_blank" rel="noopener">Numpy&lt;/a> é um pacote fundamental para a computação científica em Python. Dentre outras coisas, destaca-se pela definição e &lt;strong>manipulação de arranjos de dados multidimensionais&lt;/strong> (tensores), conveniente álgebra linear, transformada de Fourier e capacidade de produzir números aleatórios.&lt;/p>
&lt;p>No nível anterior, o problema do movimento uniformemente variável foi resolvido para obter a distância de deslocamento para um único ponto no tempo. Vamos usar um espaço linear do Numpy, indo de 0 à 20, discretizado em 51 pontos temporais. O código é o que segue:&lt;/p>
&lt;pre>&lt;code class="language-Python"># Importamos a biblioteca
import numpy
# Criamos o espaço linear
tempo = numpy.linspace(0, 20, num=51, endpoint=True)
# Exibimos a variável na tela
tempo
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-text">array([ 0. , 0.4, 0.8, 1.2, 1.6, 2. , 2.4, 2.8, 3.2, 3.6, 4. ,
4.4, 4.8, 5.2, 5.6, 6. , 6.4, 6.8, 7.2, 7.6, 8. , 8.4,
8.8, 9.2, 9.6, 10. , 10.4, 10.8, 11.2, 11.6, 12. , 12.4, 12.8,
13.2, 13.6, 14. , 14.4, 14.8, 15.2, 15.6, 16. , 16.4, 16.8, 17.2,
17.6, 18. , 18.4, 18.8, 19.2, 19.6, 20. ])
&lt;/code>&lt;/pre>
&lt;p>Calculamos novamente o deslocamento, agora para o vetor do bloco anterior, para cada ponto no espaço temporal teremos o retorno da respectiva posição, usando o seguinte código:&lt;/p>
&lt;pre>&lt;code class="language-Python"># Calcula o vetor posição
posicao = S0 + v0 * tempo + (a * tempo ** 2) / 2
# Exibe o resultado na tela
posicao
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-text">array([ 0. , 3.92, 7.68, 11.28, 14.72, 18. , 21.12, 24.08, 26.88,
29.52, 32. , 34.32, 36.48, 38.48, 40.32, 42. , 43.52, 44.88,
46.08, 47.12, 48. , 48.72, 49.28, 49.68, 49.92, 50. , 49.92,
49.68, 49.28, 48.72, 48. , 47.12, 46.08, 44.88, 43.52, 42. ,
40.32, 38.48, 36.48, 34.32, 32. , 29.52, 26.88, 24.08, 21.12,
18. , 14.72, 11.28, 7.68, 3.92, 0. ])
&lt;/code>&lt;/pre>
&lt;p>Podemos extrair mais informações do vetor posição que obtivemos no bloco anterior, se lembrarmos que a velocidade para cada instante é igual ao diferencial da posição com relação ao tempo.
Mostrar exatamente como se programa um esquema diferencial é uma boa opção para um curso de métodos numéricos, ou a turma pode ser convidada a programar por si mesma.
De qualquer modo, pode-se verificar o resultado também utilizando as funções de cálculo numérico que acompanham a biblioteca Numpy, como por exemplo &lt;a href="https://numpy.org/doc/stable/reference/generated/numpy.gradient.html" target="_blank" rel="noopener">numpy.gradient&lt;/a>. Note que, em Python, pode-se acessar a documentação da função ao digitar &lt;code>help(numpy.gradient)&lt;/code>, ou ainda com o comando mágico &lt;code>numpy.gradient?&lt;/code> quando em um ambiente Jupyter. O comando &lt;code>numpy.gradient??&lt;/code> retorna o código fonte da função, possibilitando assim investigar como ela realmente foi programada.
O primeiro argumento informado para a função é o arranjo sobre o qual será calculado o gradiente, seguido pelo arranjo de coordenadas, o tempo nesse caso. &lt;code>edge_order&lt;/code> é um argumento opcional que permite escolher a precisão da derivada junto aos contornos, por padrão esse valor é 1, mas podemos usar segunda ordem ao escolher o valor 2. Veja como fica o código:&lt;/p>
&lt;pre>&lt;code class="language-python"># Diferencial da posição com relação ao tempo
velocidade = numpy.gradient(posicao, tempo, edge_order=2)
# Exibe o resultado na tela
velocidade
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-text">array([ 1.00000000e+01, 9.60000000e+00, 9.20000000e+00, 8.80000000e+00,
8.40000000e+00, 8.00000000e+00, 7.60000000e+00, 7.20000000e+00,
6.80000000e+00, 6.40000000e+00, 6.00000000e+00, 5.60000000e+00,
5.20000000e+00, 4.80000000e+00, 4.40000000e+00, 4.00000000e+00,
3.60000000e+00, 3.20000000e+00, 2.80000000e+00, 2.40000000e+00,
2.00000000e+00, 1.60000000e+00, 1.20000000e+00, 8.00000000e-01,
4.00000000e-01, 7.10542736e-15, -4.00000000e-01, -8.00000000e-01,
-1.20000000e+00, -1.60000000e+00, -2.00000000e+00, -2.40000000e+00,
-2.80000000e+00, -3.20000000e+00, -3.60000000e+00, -4.00000000e+00,
-4.40000000e+00, -4.80000000e+00, -5.20000000e+00, -5.60000000e+00,
-6.00000000e+00, -6.40000000e+00, -6.80000000e+00, -7.20000000e+00,
-7.60000000e+00, -8.00000000e+00, -8.40000000e+00, -8.80000000e+00,
-9.20000000e+00, -9.60000000e+00, -1.00000000e+01])
&lt;/code>&lt;/pre>
&lt;p>A aceleração, por sua vez, é igual ao diferencial da velocidade com relação ao tempo. Seguindo a mesma lógica do bloco anterior, temos:&lt;/p>
&lt;pre>&lt;code class="language-Python"># Diferencial da velocidade com relação ao tempo
aceleracao = numpy.gradient(velocidade, tempo, edge_order=2)
# Exibe o resultado na tela
aceleracao
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-text">array([-1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.,
-1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.,
-1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.,
-1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.])
&lt;/code>&lt;/pre>
&lt;p>Note que a aceleração constante está em conformidade com o problema aqui exemplificado, do movimento uniformemente variável.&lt;/p>
&lt;p>Confira a &lt;a href="https://numpy.org/doc/" target="_blank" rel="noopener">Documentação Numpy&lt;/a> para ver tudo que o pacote tem a oferecer.&lt;/p>
&lt;h4 id="matplotlib">Matplotlib&lt;/h4>
&lt;p>&lt;a href="https://matplotlib.org/" target="_blank" rel="noopener">Matplotlib&lt;/a> é uma biblioteca de &lt;strong>plotagem em Python&lt;/strong>, que produz figuras com qualidade de publicação em uma variedade de formatos e ambientes interativos. Você pode gerar gráficos, histogramas, espectros de potência, gráficos de barras, gráficos de erro, diagramas de dispersão e muito mais, com apenas algumas linhas de código, confira a &lt;a href="https://matplotlib.org/3.1.0/gallery/index.html" target="_blank" rel="noopener">Galeria de Exemplos&lt;/a>.&lt;/p>
&lt;p>Seguindo o caso de estudo dessa postagem, a visualização dos resultados do movimento uniformemente variável é realizada com o seguinte bloco de código:&lt;/p>
&lt;pre>&lt;code class="language-Python"># Importamos o pacote
from matplotlib import pyplot
# Descrevemos as três linhas que irão compor o gráfico
pyplot.plot(tempo, posicao, label = 'Posição')
pyplot.plot(tempo, velocidade, label = 'Velocidade')
pyplot.plot(tempo, aceleracao, label = 'Aceleração')
# Ativamos a legenda
pyplot.legend()
# Definimos a notação do eixo horizontal
pyplot.xlabel('Tempo')
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="matplotlib.svg" alt="Exemplo Matplotlib">&lt;/p>
&lt;p>E assim, além da análise numérica, temos ferramentas de &lt;strong>visualização integradas ao ambiente Jupyter&lt;/strong>. Os alunos são convidados a interagir com a aplicação, podendo facilmente alterar os parâmetros do problema e investigar as mudanças provocadas nos resultados.&lt;/p>
&lt;h4 id="sympy">Sympy&lt;/h4>
&lt;p>&lt;a href="https://www.sympy.org" target="_blank" rel="noopener">Sympy&lt;/a> é uma biblioteca Python para &lt;strong>matemática simbólica&lt;/strong>. Seu objetivo é tornar-se um sistema de álgebra computacional (CAS) completo, mantendo o código o mais simples possível, para ser compreendido e facilmente extensível.&lt;/p>
&lt;p>Exemplificamos o uso de matemática simbólica aqui em nosso estudo de caso. Para tanto, importamos Sympy, atribuímos para variáveis Python as suas representações simbólicas com &lt;a href="https://docs.sympy.org/latest/modules/core.html#module-sympy.core.symbol" target="_blank" rel="noopener">sympy.symbols&lt;/a>, construímos a equação analítica para o movimento uniformemente variável, e por fim apresentamos a equação resultante na tela:&lt;/p>
&lt;pre>&lt;code class="language-Python">import sympy # Importamos o pacote
# Declaramos os símbolos
S0, v0, a, t = sympy.symbols(&amp;quot;S_0 v_0 a t&amp;quot;)
# Atribuímos a equação proposta
eq_posicao = S0 + v0 * t + (a * t ** 2) / 2
# Exibimos a equação na tela
eq_posicao
&lt;/code>&lt;/pre>
&lt;p>$$ S_0 + v_0t + \dfrac{at^2}{2} $$&lt;/p>
&lt;p>Um recurso interessante é a substituição alguns dos símbolos por um valor numérico:&lt;/p>
&lt;pre>&lt;code class="language-Python">eq_posicao.subs({S0: 0, v0: 10, a: -1})
&lt;/code>&lt;/pre>
&lt;p>$$ - \frac{t^{2}}{2} + 10 t$$&lt;/p>
&lt;p>Com isso, podemos graficar (com Matplotlib) a solução analítica:&lt;/p>
&lt;pre>&lt;code class="language-Python">sympy.plotting.plot(
eq_posicao.subs({S0: 0, a: -1, v0: 10}), (t, 0, 20), legend=True
)
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="sympy.svg" alt="Exemplo Sympy">&lt;/p>
&lt;p>Ou ainda substituir todos os valores, e obter o dado deslocamento para o tempo 10, por exemplo:&lt;/p>
&lt;pre>&lt;code class="language-Python">eq_posicao.subs({S0: 0, v0: 10, a: -1, t: 10})
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-text">50.0
&lt;/code>&lt;/pre>
&lt;p>A solução analítica para a velocidade é obtida ao diferenciar a equação da posição em relação ao tempo:&lt;/p>
&lt;pre>&lt;code class="language-Python"># Velocidade é o diferencial da posição pelo tempo
eq_velocidade = sympy.diff(eq_posicao, t)
# Exibimos a equação na tela
eq_velocidade
&lt;/code>&lt;/pre>
&lt;p>$$ a t + v_{0} $$&lt;/p>
&lt;p>De maneira semelhante, a solução analítica para a aceleração é obtida ao diferenciar a equação da velocidade em relação ao tempo:&lt;/p>
&lt;pre>&lt;code class="language-Python"># Aceleração é o diferencial da velocidade pelo tempo
eq_aceleracao = sympy.diff(eq_velocidade, t)
# Exibimos a equação na tela
eq_aceleracao
&lt;/code>&lt;/pre>
&lt;p>$$ a $$&lt;/p>
&lt;p>A aceleração é uma constante, afinal, esse é o movimento uniformemente variável.&lt;/p>
&lt;p>Muitos outros recursos estão disponíveis para a álgebra analítica com Sympy, como derivadas, integrais, limites, expansões em séries, aproximação para esquemas de diferenças finitas, resolução de equações (inclusive equações diferenciais), álgebra matricial, inequações, estatística, probabilidade, e muitos outros. Para uma visão completa, consulte a &lt;a href="https://docs.sympy.org/" target="_blank" rel="noopener">Documentação Sympy&lt;/a>.&lt;/p>
&lt;h4 id="scipy">Scipy&lt;/h4>
&lt;p>Por último, mas não menos importante, &lt;a href="https://www.scipy.org/" target="_blank" rel="noopener">Scipy&lt;/a>.
Mais do que uma biblioteca Python, Scipy é uma coleção de software de &lt;strong>código aberto para computação científica em Python&lt;/strong>. Fazem parte do projeto Numpy, Matplotlib e Sympy, que foram demonstradas anteriormente, &lt;a href="https://ipython.org/" target="_blank" rel="noopener">IPython&lt;/a>, que é na verdade o precursor do Projeto Jupyter, além de Pandas, que veremos a seguir.
Por estarem todas essas importantes bibliotecas no contexto de um mesmo projeto, percebemos a grande sinergia e interoperabilidade entre elas.&lt;/p>
&lt;p>Além disso, a própria biblioteca Scipy, um componente do universo Scipy, fornece muitas rotinas numéricas para: Integração numérica, diferenciação numérica, otimização, interpolação, transformada de Fourier, processamento de sinal, álgebra linear e álgebra linear esparsa, solução de problemas de autovalor, estatística, processamento de imagens e I/O de arquivos. Confira todos os detalhes na &lt;a href="https://docs.scipy.org/doc/" target="_blank" rel="noopener">Documentação Scipy&lt;/a>.&lt;/p>
&lt;h3 id="nível-avançado">Nível Avançado&lt;/h3>
&lt;p>Após construir a base da solução de problemas por ferramentas numéricas e analíticas na seção anterior, além de vermos como realizar gráficos com Matplotlib, chegamos agora à etapa final.&lt;/p>
&lt;p>Nesse ponto, vale destacar a importância de balancear o nível de complexidade da resolução dos problemas com a expectativa didática, a experiência dos alunos pode ser frustrante ao se deparar com centenas de linha de código sem sentido. Esse ponto de equilíbrio deve ser avaliado caso a caso.&lt;/p>
&lt;p>A seguir, veremos alternativas para estruturas de dados, e também opções para produção de figuras interativas, que são uma grande ajuda para análise e interpretação dos resultados. Vale destacar que embora esses elementos apresentem uma barreira de entrada ligeiramente maior, uma vez sejam dominados, acabam por simplificar o fluxo de trabalho, permitindo &lt;strong>resolver problemas mais complicados utilizando menos linhas de código&lt;/strong>.&lt;/p>
&lt;h4 id="estruturas-de-dados">Estruturas de Dados&lt;/h4>
&lt;p>Um passo natural após dominar Numpy, é partir para estruturas de dados mais elaboradas.
O &lt;a href="https://pandas.pydata.org/" target="_blank" rel="noopener">Pandas&lt;/a> é um pacote Python que fornece &lt;strong>estruturas de dados rápidas, flexíveis e expressivas&lt;/strong>, projetadas para tornar o trabalho com dados &lt;em>relacionais&lt;/em> ou &lt;em>rotulados&lt;/em> fáceis e intuitivos.
A ferramenta apresenta dois tipos primários de estruturas de dados: &lt;a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.html#pandas.Series" target="_blank" rel="noopener">Series&lt;/a> (unidimensional) e &lt;a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html#pandas.DataFrame" target="_blank" rel="noopener">DataFrame&lt;/a> (bidimensional); sendo ideal para trabalhar com dados tabelados (SQL, arquivos Excel ou CSV, por exemplo), que cobre a vasta maioria da análise de dados em casos como finanças, estatística, ciências sociais e diversas áreas da engenharia.
Uma das vantagens de utilizar Pandas é a facilidade com que podemos converter dados entre diferentes ferramentas. Na verdade, Pandas foi justamente construída sobre Numpy, e projetada para se integrar perfeitamente com todo a ambiente de computação científica.&lt;/p>
&lt;p>Seguindo o nosso estudo de caso, podemos agrupar os quatro vetores que construímos em Numpy em uma única estrutura Pandas, segundo o código:&lt;/p>
&lt;pre>&lt;code class="language-Python"># Importamos o pacote
import pandas
# Criamos um DataFrame com base nos vetores
# que produzimos anteriormente com Numpy
tabela = pandas.DataFrame(
{
&amp;quot;Tempo&amp;quot;: tempo,
&amp;quot;Posição&amp;quot;: posicao,
&amp;quot;Velocidade&amp;quot;: velocidade,
&amp;quot;Aceleração&amp;quot;: aceleracao,
},
)
# Exibimos as 5 primeiras linhas da tabela na tela com .head()
tabela.head()
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:right">&lt;/th>
&lt;th style="text-align:right">Tempo&lt;/th>
&lt;th style="text-align:right">Posição&lt;/th>
&lt;th style="text-align:right">Velocidade&lt;/th>
&lt;th style="text-align:right">Aceleração&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:right">0&lt;/td>
&lt;td style="text-align:right">0&lt;/td>
&lt;td style="text-align:right">0&lt;/td>
&lt;td style="text-align:right">10&lt;/td>
&lt;td style="text-align:right">-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">1&lt;/td>
&lt;td style="text-align:right">0.4&lt;/td>
&lt;td style="text-align:right">3.92&lt;/td>
&lt;td style="text-align:right">9.6&lt;/td>
&lt;td style="text-align:right">-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">2&lt;/td>
&lt;td style="text-align:right">0.8&lt;/td>
&lt;td style="text-align:right">7.68&lt;/td>
&lt;td style="text-align:right">9.2&lt;/td>
&lt;td style="text-align:right">-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">3&lt;/td>
&lt;td style="text-align:right">1.2&lt;/td>
&lt;td style="text-align:right">11.28&lt;/td>
&lt;td style="text-align:right">8.8&lt;/td>
&lt;td style="text-align:right">-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">4&lt;/td>
&lt;td style="text-align:right">1.6&lt;/td>
&lt;td style="text-align:right">14.72&lt;/td>
&lt;td style="text-align:right">8.4&lt;/td>
&lt;td style="text-align:right">-1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Obtemos facilmente uma descrição dos dados, incluindo a contagem, média, desvio padrão, e outros, basta utilizar o método &lt;code>.describe()&lt;/code>, como segue:&lt;/p>
&lt;pre>&lt;code class="language-Python">tabela.describe()
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">&lt;/th>
&lt;th style="text-align:right">Tempo&lt;/th>
&lt;th style="text-align:right">Posição&lt;/th>
&lt;th style="text-align:right">Velocidade&lt;/th>
&lt;th style="text-align:right">Aceleração&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">count&lt;/td>
&lt;td style="text-align:right">51&lt;/td>
&lt;td style="text-align:right">51&lt;/td>
&lt;td style="text-align:right">51&lt;/td>
&lt;td style="text-align:right">51&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">mean&lt;/td>
&lt;td style="text-align:right">10&lt;/td>
&lt;td style="text-align:right">32.6667&lt;/td>
&lt;td style="text-align:right">1.2539e-15&lt;/td>
&lt;td style="text-align:right">-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">std&lt;/td>
&lt;td style="text-align:right">5.94643&lt;/td>
&lt;td style="text-align:right">15.6486&lt;/td>
&lt;td style="text-align:right">5.94643&lt;/td>
&lt;td style="text-align:right">8.35323e-14&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">min&lt;/td>
&lt;td style="text-align:right">0&lt;/td>
&lt;td style="text-align:right">0&lt;/td>
&lt;td style="text-align:right">-10&lt;/td>
&lt;td style="text-align:right">-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">25%&lt;/td>
&lt;td style="text-align:right">5&lt;/td>
&lt;td style="text-align:right">21.12&lt;/td>
&lt;td style="text-align:right">-5&lt;/td>
&lt;td style="text-align:right">-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">50%&lt;/td>
&lt;td style="text-align:right">10&lt;/td>
&lt;td style="text-align:right">36.48&lt;/td>
&lt;td style="text-align:right">7.10543e-15&lt;/td>
&lt;td style="text-align:right">-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">75%&lt;/td>
&lt;td style="text-align:right">15&lt;/td>
&lt;td style="text-align:right">46.6&lt;/td>
&lt;td style="text-align:right">5&lt;/td>
&lt;td style="text-align:right">-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">max&lt;/td>
&lt;td style="text-align:right">20&lt;/td>
&lt;td style="text-align:right">50&lt;/td>
&lt;td style="text-align:right">10&lt;/td>
&lt;td style="text-align:right">-1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Conseguimos graficar todos os dados contidos na tabela com o método do DataFrame Pandas &lt;code>.plot()&lt;/code>, que internamente está invocando Matplotlib, mas para o usuário, basta digitar:&lt;/p>
&lt;pre>&lt;code class="language-Python">tabela.plot(x='Tempo')
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="matplotlib.svg" alt="Exemplo Matplotlib">&lt;/p>
&lt;p>Note que é exatamente a mesma figura que obtivemos antes com Matplotlib, mas dessa vez necessitamos de apenas uma linha de código. Recomenda-se a leitura da &lt;a href="https://pandas.pydata.org/docs/getting_started/overview.html" target="_blank" rel="noopener">Documentação Pandas&lt;/a> para uma visão geral de todas as vantagens que o pacote oferece.&lt;/p>
&lt;p>Pandas funciona muito bem para dados 1D e 2D, mas &lt;strong>e se o problema tiver mais dimensões&lt;/strong>? Bom, felizmente para esse caso temos &lt;a href="http://xarray.pydata.org/en/stable/" target="_blank" rel="noopener">Xarray&lt;/a>, um pacote Python para lidar com arranjos catalogados N-dimensionais, também construído sobre Numpy, e com as funcionalidades fortemente inspiradas em Pandas. Xarray é ainda capaz de lidar com computação paralela e mesmo arquivos maiores do que a memória disponível, graças a sua integração com &lt;a href="https://dask.org/" target="_blank" rel="noopener">Dask&lt;/a>. Temos um tutorial completo disponível em:&lt;/p>
&lt;h4 id="figuras-interativas">Figuras Interativas&lt;/h4>
&lt;p>Para exposição interativa dos resultados, possibilitando um &lt;em>conversa&lt;/em> com os dados, outros pacotes gráficos Python surgem como alternativa à Matplotlib. Um exemplo é &lt;a href="https://plotly.com/" target="_blank" rel="noopener">Plotly&lt;/a>, que também está disponível para R e JavaScript. Os nossos dados tabelados são apresentados de maneira interativa com o seguinte bloco de código (experimente interagir com o mouse e testar as diferentes ferramentas):&lt;/p>
&lt;pre>&lt;code class="language-Python">import plotly.express as px
fig = px.line(
tabela,
x=&amp;quot;Tempo&amp;quot;,
y=[&amp;quot;Posição&amp;quot;, &amp;quot;Velocidade&amp;quot;, &amp;quot;Aceleração&amp;quot;],
title=&amp;quot;Uma Figura Interativa&amp;quot;,
)
fig.show()
&lt;/code>&lt;/pre>
&lt;div id="chart-376248195" class="chart">&lt;/div>
&lt;script>
(function() {
let a = setInterval( function() {
if ( typeof window.Plotly === 'undefined' ) {
return;
}
clearInterval( a );
Plotly.d3.json("./example.json", function(chart) {
Plotly.plot('chart-376248195', chart.data, chart.layout, {responsive: true});
});
}, 500 );
})();
&lt;/script>
&lt;p>Novamente, no contexto educacional, &lt;strong>a turma é convidada a interagir com os resultados&lt;/strong>, modificar parâmetros, analisar os novos resultados, em um aprendizado ativo.&lt;/p>
&lt;p>Existe uma série de outras ferramentas gráficas interativas disponíveis para as mais diversas aplicações, podemos citar:
&lt;a href="https://altair-viz.github.io/" target="_blank" rel="noopener">altair&lt;/a>,
&lt;a href="https://bokeh.org/" target="_blank" rel="noopener">bokeh&lt;/a>,
&lt;a href="https://holoviews.org/" target="_blank" rel="noopener">holoviews&lt;/a>,
e &lt;a href="https://seaborn.pydata.org/" target="_blank" rel="noopener">seaborn&lt;/a>.&lt;/p>
&lt;h4 id="outros">Outros&lt;/h4>
&lt;p>Temos algumas outras ferramentas que merecem destaque no ambiente Jupyter com aplicações didáticas:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/jupyter-widgets/ipywidgets" target="_blank" rel="noopener">ipywidgets&lt;/a> fornece uma série de widgets interativos, como botões, caixas de seleção, controles deslizantes e muito mais, permitindo criar ferramentas interativas avançadas para análise e resolução de problemas, uma opção perfeita para aplicativos de ensino;&lt;/li>
&lt;li>&lt;a href="https://github.com/voila-dashboards/voila" target="_blank" rel="noopener">voilà&lt;/a> permite exportar todos os elementos de um Jupyter Notebook para uma apresentação em estilo aplicativo web. Confira a &lt;a href="https://voila-gallery.org/" target="_blank" rel="noopener">Galeria Voilà&lt;/a> para visualizar diversos exemplos;&lt;/li>
&lt;li>&lt;a href="https://nbgrader.readthedocs.io/en/stable/" target="_blank" rel="noopener">nbgrader&lt;/a> é uma ferramenta voltada para auxiliar os instrutores na atribuição e avaliação de tarefas em Jupyter Notebooks.&lt;/li>
&lt;/ul>
&lt;!--adsense-->
&lt;h2 id="leitura-recomendada">Leitura Recomendada&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Teaching and Learning with Jupyter&lt;/strong>, &lt;em>Lorena A. Barba, Lecia J. Barker, Douglas S. Blank, Jed Brown, Allen B. Downey, Timothy George, Lindsey J. Heagy, Kyle T. Mandli, Jason K. Moore, David Lippert, Kyle E. Niemeyer, Ryan R. Watkins, Richard H. West, Elizabeth Wickes, Carol Willing, and Michael Zingale&lt;/em>. Open Book 2019. &lt;a href="https://jupyter4edu.github.io/jupyter-edu-book/" target="_blank" rel="noopener">Disponível online&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h2 id="exemplos">Exemplos&lt;/h2>
&lt;ul>
&lt;li>
&lt;div class="view-list-item">
&lt;i class="far fa-calendar-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;a href="https://www.fschuch.com/talk/metodos-numericos-em-python/" >Métodos Numéricos em Python&lt;/a>
&lt;div class="article-metadata">
&lt;span>
May 4, 2021 3:30 PM &amp;mdash; 5:30 PM
&lt;/span>
&lt;span class="middot-divider">&lt;/span>
&lt;span>PPGRHSA, IPH, UFRGS&lt;/span>
&lt;/div>
&lt;div class="btn-links">
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://github.com/fschuch/metodos-numericos-com-python" target="_blank" rel="noopener">
&lt;i class="fab fa-github mr-1">&lt;/i>
Veja no GitHub
&lt;/a>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;div class="view-list-item">
&lt;i class="far fa-calendar-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;a href="https://www.fschuch.com/talk/python-introducao-e-aplicacoes-da-linguagem-de-programacao-em-engenharia/" >Python: Introdução e Aplicações da Linguagem de Programação em Engenharia&lt;/a>
&lt;div class="article-metadata">
&lt;span>
Jul 16, 2019 2:00 PM &amp;mdash; Jul 16, 2020 5:30 PM
&lt;/span>
&lt;span class="middot-divider">&lt;/span>
&lt;span>Escola Politécnica, PUCRS&lt;/span>
&lt;/div>
&lt;div class="btn-links">
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://github.com/fschuch/JAEP-2019.py" target="_blank" rel="noopener">
&lt;i class="fab fa-github mr-1">&lt;/i>
Veja no GitHub
&lt;/a>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;div class="view-list-item">
&lt;i class="far fa-calendar-alt pub-icon" aria-hidden="true">&lt;/i>
&lt;a href="https://www.fschuch.com/talk/metodos-numericos-aplicados-a-transferencia-de-calor/" >Métodos Numéricos Aplicados à Transferência de Calor&lt;/a>
&lt;div class="article-metadata">
&lt;span>
Oct 9, 2019 7:30 PM &amp;mdash; Oct 9, 2020 8:15 PM
&lt;/span>
&lt;span class="middot-divider">&lt;/span>
&lt;span>Escola Politécnica, PUCRS&lt;/span>
&lt;/div>
&lt;div class="btn-links">
&lt;a class="btn btn-outline-primary btn-page-header btn-sm" href="https://github.com/fschuch/Python-Transferencia-de-Calor" target="_blank" rel="noopener">
&lt;i class="fab fa-github mr-1">&lt;/i>
Veja no GitHub
&lt;/a>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;div class="view-list-item">
&lt;i class="far fa-newspaper pub-icon" aria-hidden="true">&lt;/i>
&lt;a href="https://www.fschuch.com/blog/2020/01/12/cfd-com-python-12-passos-para-navier-stokes/" >CFD com Python: 12 Passos para Navier-Stokes&lt;/a>
&lt;div class="btn-links">
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;div class="view-list-item">
&lt;i class="far fa-newspaper pub-icon" aria-hidden="true">&lt;/i>
&lt;a href="https://www.fschuch.com/blog/2020/04/11/alugar-economizar-e-pagar-a-vista-ou-financiar-um-imovel-um-estudo-de-caso/" >Alugar, economizar e pagar à vista ou financiar um imóvel? Um estudo de caso&lt;/a>
&lt;div class="btn-links">
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ul>
&lt;h2 id="conclusão">Conclusão&lt;/h2>
&lt;p>Esse foi um material demonstrativo sobre o emprego do Jupyter Notebook no contexto didático, uma vez que a ferramenta permite misturar trechos de texto descritivo com blocos de código interativos (assim como essa própria postagem), visando aumentar a participação, engajamento e desempenho dos estudantes das mais diversas áreas do conhecimento.
Jupyter é um software gratuito e de código aberto, disponível em todos os sistemas operacionais e em servidores na nuvem (teste sem nenhuma instalação), além de ser compatível com dezenas de diferentes linguagens de programação.
Por ser tão flexível, se enquadra não apenas em áreas do conhecimento onde a programação é um objetivo final, mas também em áreas onde a programação se apresenta como um meio para analisar e resolver problemas.
Para uma demonstração mais imersivas, diversos pacotes Python de aplicação geral foram exemplificados.
Certamente existe uma infinidade de outros pacotes Python com relevância ao contexto educacional, principalmente quando pensamos em soluções para problemas de domínios mais específicos.
Mas de qualquer maneira, espero que essa leitura auxilie na disseminação dessa incrível ferramenta de ensino.&lt;/p></description></item><item><title>Obtenção e manipulação de dados históricos do mercado financeiro</title><link>https://www.fschuch.com/blog/2020/05/21/obtencao-e-manipulacao-de-dados-historicos-do-mercado-financeiro/</link><pubDate>Thu, 21 May 2020 00:00:00 +0000</pubDate><guid>https://www.fschuch.com/blog/2020/05/21/obtencao-e-manipulacao-de-dados-historicos-do-mercado-financeiro/</guid><description>&lt;details class="toc-inpage d-print-none " open>
&lt;summary class="font-weight-bold">Lista de Conteúdos&lt;/summary>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>&lt;a href="#introdução">Introdução&lt;/a>&lt;/li>
&lt;li>&lt;a href="#obtenção-e-manipulação-dos-dados">Obtenção e manipulação dos dados&lt;/a>&lt;/li>
&lt;li>&lt;a href="#visualização">Visualização&lt;/a>&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;/details>
&lt;h2 id="introdução">Introdução&lt;/h2>
&lt;p>A análise de dados históricos do mercado financeiro pode ser prática para diversos fins, como estudos acadêmicos, gerenciamento de portfólio, criação de conteúdo e outros.&lt;/p>
&lt;p>Boa parte dos materiais por aí são baseados naqueles famosos aplicativos de planilha, nada contra, mas eu gosto mesmo de resolver os problemas propostos usando Python. Para isso, vamos usar dois pacotes:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/ranaroussi/yfinance" target="_blank" rel="noopener">yfinance&lt;/a> oferece uma alternativa em Python para baixar dados históricos do mercado financeiro a partir do Yahoo! finanças;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/matplotlib/mplfinance" target="_blank" rel="noopener">mplfinance&lt;/a> é uma utilidade construída sobre Matplotlib, que oferece visualização e análise para dados financeiros.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="alert alert-note">
&lt;div>
Lembre-se sempre que lucros passados não são garantia de lucros futuros, e que esse post não é uma recomendação de compra.
&lt;/div>
&lt;/div>
&lt;p>O primeiro passo é instalar os pacotes que usaremos, e isso pode ser feito no ambiente Jupyter (como esse post) com o seguinte comando mágico:&lt;/p>
&lt;pre>&lt;code class="language-python">!pip install -q yfinance mplfinance
&lt;/code>&lt;/pre>
&lt;p>E então importamos ambos para a nossa aplicação:&lt;/p>
&lt;pre>&lt;code class="language-python">import yfinance as yf
import mplfinance as mpf
&lt;/code>&lt;/pre>
&lt;!--adsense-->
&lt;h2 id="obtenção-e-manipulação-dos-dados">Obtenção e manipulação dos dados&lt;/h2>
&lt;p>O módulo &lt;code>Ticker&lt;/code> nos permite o acesso a diversos dados de maneira integrada ao Python, e apenas para exemplificar, usaremos a Microsoft, código de negociação &lt;code>MSFT&lt;/code>:&lt;/p>
&lt;pre>&lt;code class="language-python">msft = yf.Ticker(&amp;quot;MSFT&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>Informações completas da companhia são obtidos com o método &lt;code>info&lt;/code>, como segue:&lt;/p>
&lt;pre>&lt;code class="language-python">msft.info
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-text"> {'zip': '98052-6399',
'sector': 'Technology',
'fullTimeEmployees': 163000,
'longBusinessSummary': 'Microsoft Corporation develops, licenses, and supports software, services, devices, and solutions worldwide. Its Productivity and Business Processes segment offers Office, Exchange, SharePoint, Microsoft Teams, Office 365 Security and Compliance, and Skype for Business, as well as related Client Access Licenses (CAL); Skype, Outlook.com, and OneDrive; LinkedIn that includes Talent, Learning, Sales, and Marketing solutions, as well as premium subscriptions; and Dynamics 365, a set of cloud-based and on-premises business solutions for small and medium businesses, large organizations, and divisions of enterprises. Its Intelligent Cloud segment licenses SQL and Windows Servers, Visual Studio, System Center, and related CALs; GitHub that provides a collaboration platform and code hosting service for developers; and Azure, a cloud platform. It also offers support services and Microsoft consulting services to assist customers in developing, deploying, and managing Microsoft server and desktop solutions; and training and certification to developers and IT professionals on various Microsoft products. Its More Personal Computing segment provides Windows original equipment manufacturer (OEM) licensing and other non-volume licensing of the Windows operating system; Windows Commercial, such as volume licensing of the Windows operating system, Windows cloud services, and other Windows commercial offerings; patent licensing; Windows Internet of Things; and MSN advertising. It also offers Surface, PC accessories, PCs, tablets, gaming and entertainment consoles, and other intelligent devices; Gaming, including Xbox hardware, and Xbox content and services; video games and third-party video game royalties; and Search, including Bing and Microsoft advertising. It sells its products through OEMs, distributors, and resellers; and directly through digital marketplaces, online stores, and retail stores. The company was founded in 1975 and is headquartered in Redmond, Washington.',
'city': 'Redmond',
'phone': '425-882-8080',
'state': 'WA',
'country': 'United States',
'companyOfficers': [],
'website': 'http://www.microsoft.com',
'maxAge': 1,
'address1': 'One Microsoft Way',
'industry': 'Software—Infrastructure',
'previousClose': 219.66,
'regularMarketOpen': 220.15,
'twoHundredDayAverage': 196.80064,
'trailingAnnualDividendYield': 0.00928708,
'payoutRatio': 0.3455,
'volume24Hr': None,
'regularMarketDayHigh': 222.29,
'navPrice': None,
'averageDailyVolume10Day': 27025187,
'totalAssets': None,
'regularMarketPreviousClose': 219.66,
'fiftyDayAverage': 212.05457,
'trailingAnnualDividendRate': 2.04,
'open': 220.15,
'toCurrency': None,
'averageVolume10days': 27025187,
'expireDate': None,
'yield': None,
'algorithm': None,
'dividendRate': 2.24,
'exDividendDate': 1605657600,
'beta': 0.923331,
'circulatingSupply': None,
'startDate': None,
'regularMarketDayLow': 219.33,
'priceHint': 2,
'currency': 'USD',
'trailingPE': 38.135414,
'regularMarketVolume': 25074770,
'lastMarket': None,
'maxSupply': None,
'openInterest': None,
'marketCap': 1662310023168,
'volumeAllCurrencies': None,
'strikePrice': None,
'averageVolume': 33866804,
'priceToSalesTrailing12Months': 11.623326,
'dayLow': 219.33,
'ask': 219,
'ytdReturn': None,
'askSize': 1000,
'volume': 25074770,
'fiftyTwoWeekHigh': 232.86,
'forwardPE': 29.967258,
'fromCurrency': None,
'fiveYearAvgDividendYield': 1.8,
'fiftyTwoWeekLow': 132.52,
'bid': 219,
'tradeable': False,
'dividendYield': 0.010199999,
'bidSize': 1300,
'dayHigh': 222.29,
'exchange': 'NMS',
'shortName': 'Microsoft Corporation',
'longName': 'Microsoft Corporation',
'exchangeTimezoneName': 'America/New_York',
'exchangeTimezoneShortName': 'EDT',
'isEsgPopulated': False,
'gmtOffSetMilliseconds': '-14400000',
'quoteType': 'EQUITY',
'symbol': 'MSFT',
'messageBoardId': 'finmb_21835',
'market': 'us_market',
'annualHoldingsTurnover': None,
'enterpriseToRevenue': 11.243,
'beta3Year': None,
'profitMargins': 0.30962,
'enterpriseToEbitda': 24.639,
'52WeekChange': 0.59857357,
'morningStarRiskRating': None,
'forwardEps': 7.33,
'revenueQuarterlyGrowth': None,
'sharesOutstanding': 7567649792,
'fundInceptionDate': None,
'annualReportExpenseRatio': None,
'bookValue': 15.626,
'sharesShort': 39634230,
'sharesPercentSharesOut': 0.0052,
'fundFamily': None,
'lastFiscalYearEnd': 1593475200,
'heldPercentInstitutions': 0.74093,
'netIncomeToCommon': 44280999936,
'trailingEps': 5.76,
'lastDividendValue': 0.51,
'SandP52WeekChange': 0.16647923,
'priceToBook': 14.057341,
'heldPercentInsiders': 0.014249999,
'nextFiscalYearEnd': 1656547200,
'mostRecentQuarter': 1593475200,
'shortRatio': 1.09,
'sharesShortPreviousMonthDate': 1598832000,
'floatShares': 7455727348,
'enterpriseValue': 1607928643584,
'threeYearAverageReturn': None,
'lastSplitDate': 1045526400,
'lastSplitFactor': '2:1',
'legalType': None,
'lastDividendDate': 1597795200,
'morningStarOverallRating': None,
'earningsQuarterlyGrowth': -0.151,
'dateShortInterest': 1601424000,
'pegRatio': 2.29,
'lastCapGain': None,
'shortPercentOfFloat': 0.0053,
'sharesShortPriorMonth': 36458662,
'category': None,
'fiveYearAverageReturn': None,
'regularMarketPrice': 220.15,
'logo_url': 'https://logo.clearbit.com/microsoft.com'}
&lt;/code>&lt;/pre>
&lt;p>Pode-se obter informações sobre os principais acionistas:&lt;/p>
&lt;pre>&lt;code class="language-python">msft.major_holders
&lt;/code>&lt;/pre>
&lt;div>
&lt;style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}
&lt;pre>&lt;code>.dataframe tbody tr th {
vertical-align: top;
}
.dataframe thead th {
text-align: right;
}
&lt;/code>&lt;/pre>
&lt;p>&lt;/style>&lt;/p>
&lt;table border="1" class="dataframe">
&lt;thead>
&lt;tr style="text-align: right;">
&lt;th>&lt;/th>
&lt;th>0&lt;/th>
&lt;th>1&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;th>0&lt;/th>
&lt;td>1.42%&lt;/td>
&lt;td>% of Shares Held by All Insider&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>1&lt;/th>
&lt;td>74.09%&lt;/td>
&lt;td>% of Shares Held by Institutions&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>2&lt;/th>
&lt;td>75.16%&lt;/td>
&lt;td>% of Float Held by Institutions&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>3&lt;/th>
&lt;td>4630&lt;/td>
&lt;td>Number of Institutions Holding Shares&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;pre>&lt;code class="language-python">msft.institutional_holders
&lt;/code>&lt;/pre>
&lt;div>
&lt;style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}
&lt;pre>&lt;code>.dataframe tbody tr th {
vertical-align: top;
}
.dataframe thead th {
text-align: right;
}
&lt;/code>&lt;/pre>
&lt;p>&lt;/style>&lt;/p>
&lt;table border="1" class="dataframe">
&lt;thead>
&lt;tr style="text-align: right;">
&lt;th>&lt;/th>
&lt;th>Holder&lt;/th>
&lt;th>Shares&lt;/th>
&lt;th>Date Reported&lt;/th>
&lt;th>% Out&lt;/th>
&lt;th>Value&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;th>0&lt;/th>
&lt;td>Vanguard Group, Inc. (The)&lt;/td>
&lt;td>632013255&lt;/td>
&lt;td>2020-06-29&lt;/td>
&lt;td>0.0835&lt;/td>
&lt;td>128621017525&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>1&lt;/th>
&lt;td>Blackrock Inc.&lt;/td>
&lt;td>521841633&lt;/td>
&lt;td>2020-06-29&lt;/td>
&lt;td>0.0690&lt;/td>
&lt;td>106199990731&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>2&lt;/th>
&lt;td>State Street Corporation&lt;/td>
&lt;td>314554694&lt;/td>
&lt;td>2020-06-29&lt;/td>
&lt;td>0.0416&lt;/td>
&lt;td>64015025775&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>3&lt;/th>
&lt;td>FMR, LLC&lt;/td>
&lt;td>236873992&lt;/td>
&lt;td>2020-06-29&lt;/td>
&lt;td>0.0313&lt;/td>
&lt;td>48206226111&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>4&lt;/th>
&lt;td>Price (T.Rowe) Associates Inc&lt;/td>
&lt;td>183090016&lt;/td>
&lt;td>2020-06-29&lt;/td>
&lt;td>0.0242&lt;/td>
&lt;td>37260649156&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>5&lt;/th>
&lt;td>Capital World Investors&lt;/td>
&lt;td>122923512&lt;/td>
&lt;td>2020-06-29&lt;/td>
&lt;td>0.0162&lt;/td>
&lt;td>25016163927&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>6&lt;/th>
&lt;td>Geode Capital Management, LLC&lt;/td>
&lt;td>116688974&lt;/td>
&lt;td>2020-06-29&lt;/td>
&lt;td>0.0154&lt;/td>
&lt;td>23747373098&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>7&lt;/th>
&lt;td>Capital International Investors&lt;/td>
&lt;td>98209725&lt;/td>
&lt;td>2020-06-29&lt;/td>
&lt;td>0.0130&lt;/td>
&lt;td>19986661134&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>8&lt;/th>
&lt;td>Capital Research Global Investors&lt;/td>
&lt;td>94081197&lt;/td>
&lt;td>2020-06-29&lt;/td>
&lt;td>0.0124&lt;/td>
&lt;td>19146464401&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>9&lt;/th>
&lt;td>Northern Trust Corporation&lt;/td>
&lt;td>93331898&lt;/td>
&lt;td>2020-06-29&lt;/td>
&lt;td>0.0123&lt;/td>
&lt;td>18993974561&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;p>Os dados históricos são obtidos com o método &lt;code>history()&lt;/code>, que aceita como argumentos o período desejado, ou datas de início e fim, e retorna um &lt;a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html" target="_blank" rel="noopener">Pandas &lt;code>DataFrame&lt;/code>&lt;/a> que contém os preços de abertura e fechamento do mercado, além de máximas e mínimas, o volume de negociação, informações sobre dividendos pagos e desdobramentos.&lt;/p>
&lt;pre>&lt;code class="language-python">data = msft.history(period=&amp;quot;max&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>E assim, temos a disposição todos os métodos inerentes do &lt;a href="https://pandas.pydata.org/" target="_blank" rel="noopener">Pandas&lt;/a>, como &lt;code>head()&lt;/code>, que nos mostra a parte superior da tabela de dados:&lt;/p>
&lt;pre>&lt;code class="language-python">data.head()
&lt;/code>&lt;/pre>
&lt;div>
&lt;style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}
&lt;pre>&lt;code>.dataframe tbody tr th {
vertical-align: top;
}
.dataframe thead th {
text-align: right;
}
&lt;/code>&lt;/pre>
&lt;p>&lt;/style>&lt;/p>
&lt;table border="1" class="dataframe">
&lt;thead>
&lt;tr style="text-align: right;">
&lt;th>&lt;/th>
&lt;th>Open&lt;/th>
&lt;th>High&lt;/th>
&lt;th>Low&lt;/th>
&lt;th>Close&lt;/th>
&lt;th>Volume&lt;/th>
&lt;th>Dividends&lt;/th>
&lt;th>Stock Splits&lt;/th>
&lt;/tr>
&lt;tr>
&lt;th>Date&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;th>1986-03-13&lt;/th>
&lt;td>0.06&lt;/td>
&lt;td>0.06&lt;/td>
&lt;td>0.06&lt;/td>
&lt;td>0.06&lt;/td>
&lt;td>1031788800&lt;/td>
&lt;td>0.0&lt;/td>
&lt;td>0.0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>1986-03-14&lt;/th>
&lt;td>0.06&lt;/td>
&lt;td>0.07&lt;/td>
&lt;td>0.06&lt;/td>
&lt;td>0.06&lt;/td>
&lt;td>308160000&lt;/td>
&lt;td>0.0&lt;/td>
&lt;td>0.0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>1986-03-17&lt;/th>
&lt;td>0.06&lt;/td>
&lt;td>0.07&lt;/td>
&lt;td>0.06&lt;/td>
&lt;td>0.07&lt;/td>
&lt;td>133171200&lt;/td>
&lt;td>0.0&lt;/td>
&lt;td>0.0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>1986-03-18&lt;/th>
&lt;td>0.07&lt;/td>
&lt;td>0.07&lt;/td>
&lt;td>0.06&lt;/td>
&lt;td>0.06&lt;/td>
&lt;td>67766400&lt;/td>
&lt;td>0.0&lt;/td>
&lt;td>0.0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>1986-03-19&lt;/th>
&lt;td>0.06&lt;/td>
&lt;td>0.06&lt;/td>
&lt;td>0.06&lt;/td>
&lt;td>0.06&lt;/td>
&lt;td>47894400&lt;/td>
&lt;td>0.0&lt;/td>
&lt;td>0.0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;p>Ou &lt;code>tail()&lt;/code>, que mostra a parte inferior:&lt;/p>
&lt;pre>&lt;code class="language-python">data.tail()
&lt;/code>&lt;/pre>
&lt;div>
&lt;style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}
&lt;pre>&lt;code>.dataframe tbody tr th {
vertical-align: top;
}
.dataframe thead th {
text-align: right;
}
&lt;/code>&lt;/pre>
&lt;p>&lt;/style>&lt;/p>
&lt;table border="1" class="dataframe">
&lt;thead>
&lt;tr style="text-align: right;">
&lt;th>&lt;/th>
&lt;th>Open&lt;/th>
&lt;th>High&lt;/th>
&lt;th>Low&lt;/th>
&lt;th>Close&lt;/th>
&lt;th>Volume&lt;/th>
&lt;th>Dividends&lt;/th>
&lt;th>Stock Splits&lt;/th>
&lt;/tr>
&lt;tr>
&lt;th>Date&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;th>2020-10-12&lt;/th>
&lt;td>218.79&lt;/td>
&lt;td>223.86&lt;/td>
&lt;td>216.81&lt;/td>
&lt;td>221.40&lt;/td>
&lt;td>40461400&lt;/td>
&lt;td>0.0&lt;/td>
&lt;td>0.0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>2020-10-13&lt;/th>
&lt;td>222.72&lt;/td>
&lt;td>225.21&lt;/td>
&lt;td>220.43&lt;/td>
&lt;td>222.86&lt;/td>
&lt;td>28950800&lt;/td>
&lt;td>0.0&lt;/td>
&lt;td>0.0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>2020-10-14&lt;/th>
&lt;td>223.00&lt;/td>
&lt;td>224.22&lt;/td>
&lt;td>219.13&lt;/td>
&lt;td>220.86&lt;/td>
&lt;td>23451700&lt;/td>
&lt;td>0.0&lt;/td>
&lt;td>0.0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>2020-10-15&lt;/th>
&lt;td>217.10&lt;/td>
&lt;td>220.36&lt;/td>
&lt;td>216.01&lt;/td>
&lt;td>219.66&lt;/td>
&lt;td>22718400&lt;/td>
&lt;td>0.0&lt;/td>
&lt;td>0.0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>2020-10-16&lt;/th>
&lt;td>220.15&lt;/td>
&lt;td>222.29&lt;/td>
&lt;td>219.33&lt;/td>
&lt;td>219.66&lt;/td>
&lt;td>25074770&lt;/td>
&lt;td>0.0&lt;/td>
&lt;td>0.0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;p>Podemos facilmente produzir um gráfico com o método &lt;code>plot()&lt;/code>, conforme segue:&lt;/p>
&lt;pre>&lt;code class="language-python">data.plot();
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="figura_0.svg" alt="svg">&lt;/p>
&lt;p>Essa figura ficou meio poluída visualmente, vamos nos concentrar apenas no preço de fechamento, e acrescentar algumas opções extras:&lt;/p>
&lt;pre>&lt;code class="language-python"># Acessamos apenas o preço de fechamento, plotamos com log no eixo y,
# porque é mais representativo, adicionamos um título à figura
data.Close.plot(logy=True, title=msft.info['symbol'])
# Aqui adicionamos médias móveis, porque não?
# mav vem do inglês para moving average
for mav in [500, 1000, 2000]:
data.Close.rolling(mav).mean().plot(label=f'mav {mav}')
plt.legend();
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="figura_1.svg" alt="svg">&lt;/p>
&lt;p>Podemos também calcular e graficar a variação percentual diária do preço como:&lt;/p>
&lt;pre>&lt;code class="language-python">data['Var [%]'] = 100. * (data.Close - data.Open) / data.Open
data['Var [%]'].plot();
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="figura_2.svg" alt="svg">&lt;/p>
&lt;p>Que pode ser exibida como um histograma de frequências:&lt;/p>
&lt;pre>&lt;code class="language-python">data['Var [%]'].plot.hist(bins=100);
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="figura_3.svg" alt="svg">&lt;/p>
&lt;p>Temos ainda o método &lt;code>actions()&lt;/code> que retorna dados históricos sobre dividendos e desdobramento das ações, e perceba que ele pode ser encadeado com o método &lt;code>plot()&lt;/code>, para múltiplas operações em uma única linha de código:&lt;/p>
&lt;pre>&lt;code class="language-python">msft.actions.plot();
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="figura_4.svg" alt="svg">&lt;/p>
&lt;p>O método &lt;code>describe()&lt;/code> é particularmente útil para ter uma rápida representação de uma grande quantidade de dados, fornecendo a contagem, média, desvio padrão, valor mínimo, máximo e outros.&lt;/p>
&lt;pre>&lt;code class="language-python">data.describe()
&lt;/code>&lt;/pre>
&lt;div>
&lt;style scoped>
.dataframe tbody tr th:only-of-type {
vertical-align: middle;
}
&lt;pre>&lt;code>.dataframe tbody tr th {
vertical-align: top;
}
.dataframe thead th {
text-align: right;
}
&lt;/code>&lt;/pre>
&lt;p>&lt;/style>&lt;/p>
&lt;table border="1" class="dataframe">
&lt;thead>
&lt;tr style="text-align: right;">
&lt;th>&lt;/th>
&lt;th>Open&lt;/th>
&lt;th>High&lt;/th>
&lt;th>Low&lt;/th>
&lt;th>Close&lt;/th>
&lt;th>Volume&lt;/th>
&lt;th>Dividends&lt;/th>
&lt;th>Stock Splits&lt;/th>
&lt;th>Var [%]&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;th>count&lt;/th>
&lt;td>8722.000000&lt;/td>
&lt;td>8722.000000&lt;/td>
&lt;td>8722.000000&lt;/td>
&lt;td>8722.000000&lt;/td>
&lt;td>8.722000e+03&lt;/td>
&lt;td>8722.000000&lt;/td>
&lt;td>8722.000000&lt;/td>
&lt;td>8722.000000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>mean&lt;/th>
&lt;td>26.930644&lt;/td>
&lt;td>27.217296&lt;/td>
&lt;td>26.637444&lt;/td>
&lt;td>26.937902&lt;/td>
&lt;td>6.000501e+07&lt;/td>
&lt;td>0.002196&lt;/td>
&lt;td>0.001949&lt;/td>
&lt;td>0.067909&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>std&lt;/th>
&lt;td>37.001413&lt;/td>
&lt;td>37.388700&lt;/td>
&lt;td>36.589514&lt;/td>
&lt;td>37.016185&lt;/td>
&lt;td>3.867451e+07&lt;/td>
&lt;td>0.040982&lt;/td>
&lt;td>0.061015&lt;/td>
&lt;td>2.052796&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>min&lt;/th>
&lt;td>0.060000&lt;/td>
&lt;td>0.060000&lt;/td>
&lt;td>0.060000&lt;/td>
&lt;td>0.060000&lt;/td>
&lt;td>2.304000e+06&lt;/td>
&lt;td>0.000000&lt;/td>
&lt;td>0.000000&lt;/td>
&lt;td>-25.925926&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>25%&lt;/th>
&lt;td>2.360000&lt;/td>
&lt;td>2.380000&lt;/td>
&lt;td>2.330000&lt;/td>
&lt;td>2.362500&lt;/td>
&lt;td>3.617535e+07&lt;/td>
&lt;td>0.000000&lt;/td>
&lt;td>0.000000&lt;/td>
&lt;td>-0.781170&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>50%&lt;/th>
&lt;td>18.595000&lt;/td>
&lt;td>18.805000&lt;/td>
&lt;td>18.360000&lt;/td>
&lt;td>18.590000&lt;/td>
&lt;td>5.316930e+07&lt;/td>
&lt;td>0.000000&lt;/td>
&lt;td>0.000000&lt;/td>
&lt;td>0.000000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>75%&lt;/th>
&lt;td>26.267500&lt;/td>
&lt;td>26.487500&lt;/td>
&lt;td>25.925000&lt;/td>
&lt;td>26.225000&lt;/td>
&lt;td>7.371192e+07&lt;/td>
&lt;td>0.000000&lt;/td>
&lt;td>0.000000&lt;/td>
&lt;td>0.889940&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th>max&lt;/th>
&lt;td>229.270000&lt;/td>
&lt;td>232.860000&lt;/td>
&lt;td>227.350000&lt;/td>
&lt;td>231.650000&lt;/td>
&lt;td>1.031789e+09&lt;/td>
&lt;td>3.080000&lt;/td>
&lt;td>2.000000&lt;/td>
&lt;td>16.666667&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;p>Esse foi nosso exemplo, informações complementares podem ser encontradas no &lt;a href="https://aroussi.com/post/python-yahoo-finance" target="_blank" rel="noopener">post&lt;/a> do autor original do pacote &lt;code>yfinance&lt;/code>. Experimente executar os exemplos propostos para outros códigos de negociação, por exemplo com o índice &lt;a href="https://pt.wikipedia.org/wiki/S%26P_500" target="_blank" rel="noopener">S&amp;amp;P 500&lt;/a> com o ticker &lt;code>^GSPC&lt;/code>, o índice &lt;a href="http://www.b3.com.br/pt_br/market-data-e-indices/indices/indices-amplos/ibovespa.htm" target="_blank" rel="noopener">Ibovespa&lt;/a> com o ticker &lt;code>^BVSP&lt;/code>, ou empresas brasileiras, como o ticker &lt;code>ITUB3.SA&lt;/code>, e muitos outros.&lt;/p>
&lt;!--adsense-->
&lt;h2 id="visualização">Visualização&lt;/h2>
&lt;p>A representação gráfica de dados financeiros é mais usual pelo método &lt;a href="https://pt.wikipedia.org/wiki/Candlestick" target="_blank" rel="noopener">Candlestick&lt;/a>, onde exibe-se os preços de abertura, fechamento, máximo e mínimo de maneira mais compreensiva.&lt;/p>
&lt;p>Vamos mudar os dados empregados apenas para ter um segundo exemplo da utilização do &lt;code>yfinance&lt;/code>, agora especificando uma data de início e fim para a série histórica, e agrupando os resultados no período de uma semana.&lt;/p>
&lt;pre>&lt;code class="language-python">data = yf.Ticker('^BVSP').history(start='2019-01-01', end='2019-12-31', interval='1wk')
&lt;/code>&lt;/pre>
&lt;p>E agora com &lt;code>mplfinance&lt;/code> e apenas uma linha de código, temos a nossa figura:&lt;/p>
&lt;pre>&lt;code class="language-python">mpf.plot(data, type='candle',
mav=(5,10), volume=True,
show_nontrading=True, style='yahoo',
title='Ibovespa, 2019');
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="figura_6.svg" alt="svg">&lt;/p>
&lt;p>Bem mais limpa visualmente do que a nossa primeira tentativa, não é mesmo? Perceba que o método aceita diferentes tipos de gráfico, a inclusão de médias móveis (&lt;code>mav&lt;/code>), o volume de negociações (pode mostrar, ou não), os dias em que não houveram pregão, e pode-se escolher o estilo do gráfico. Informações completas sobre o pacote &lt;code>mplfinance&lt;/code> estão disponíveis no &lt;a href="https://pypi.org/project/mplfinance/" target="_blank" rel="noopener">link&lt;/a>.&lt;/p></description></item><item><title>Alugar, economizar e pagar à vista ou financiar um imóvel? Um estudo de caso</title><link>https://www.fschuch.com/blog/2020/04/11/alugar-economizar-e-pagar-a-vista-ou-financiar-um-imovel-um-estudo-de-caso/</link><pubDate>Sat, 11 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.fschuch.com/blog/2020/04/11/alugar-economizar-e-pagar-a-vista-ou-financiar-um-imovel-um-estudo-de-caso/</guid><description>&lt;details class="toc-inpage d-print-none " open>
&lt;summary class="font-weight-bold">Lista de Conteúdos&lt;/summary>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>&lt;a href="#introdução">Introdução&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#execute-online">Execute Online&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#sistemas-de-amortização">Sistemas de Amortização&lt;/a>&lt;/li>
&lt;li>&lt;a href="#cenários">Cenários&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#financiar">Financiar&lt;/a>&lt;/li>
&lt;li>&lt;a href="#alugar-e-aportar-mensalmente">Alugar e Aportar Mensalmente&lt;/a>&lt;/li>
&lt;li>&lt;a href="#economizar-e-comprar-à-vista">Economizar e Comprar à Vista&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#síntese-dos-resultados">Síntese dos Resultados&lt;/a>&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;/details>
&lt;h2 id="introdução">Introdução&lt;/h2>
&lt;p>A matemática financeira é uma disciplina fundamental na atuação de profissionais de diversos setores e, adicionalmente, possui importante papel na gestão de recursos próprios e no gerenciamento do orçamento doméstico. É justamente nesse ponto que muitas pessoas têm seu primeiro contato com programação, e talvez nem se deem conta disso, ao utilizar alguma aplicação de manipulação de planilhas para controlar os gastos de casa. Verdade seja dita, planilhas são estruturas de dados muito úteis.&lt;/p>
&lt;p>Esta postagem trata de um estudo de cenários didáticos sobre a aquisição - ou não - de um imóvel. Ele cobre três situações:&lt;/p>
&lt;ul>
&lt;li>Comprar com uma entrada e financiamento;&lt;/li>
&lt;li>Alugar e investir mensalmente;&lt;/li>
&lt;li>Economizar e comprar à vista.&lt;/li>
&lt;/ul>
&lt;p>Para tanto, exemplifica-se como resolver o problema proposto com o emprego de duas importantes ferramentas:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://pandas.pydata.org/" target="_blank" rel="noopener">Pandas&lt;/a> é um pacote Python que fornece estruturas de dados rápidas, flexíveis e expressivas, projetadas para tornar o trabalho com dados “relacionais” ou “rotulados” fáceis e intuitivos. O objetivo é ser o alicerce fundamental de alto nível para a análise prática de dados do mundo real em Python. Além disso, tem o objetivo mais amplo de se tornar a mais prestigiada e flexível ferramenta de análise / manipulação de dados de código aberto disponível em qualquer linguagem. Pandas é bem adequado para muitos tipos diferentes de dados:
&lt;ul>
&lt;li>Dados tabulares com colunas de tipos heterogêneos, como em uma tabela SQL, arquivo &lt;code>.csv&lt;/code> ou planilha do Excel;&lt;/li>
&lt;li>Dados de séries temporais ordenados e não ordenados (não necessariamente de frequência fixa);&lt;/li>
&lt;li>Dados de matriz arbitrária (homogeneamente digitados ou heterogêneos) com rótulos de linha e coluna;&lt;/li>
&lt;li>Qualquer outra forma de conjuntos de dados observacionais / estatísticos. Os dados realmente não precisam ser rotulados para serem colocados em uma estrutura de dados de pandas.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://matplotlib.org/" target="_blank" rel="noopener">Matplotlib&lt;/a> é uma biblioteca de plotagem 2D do Python, que produz figuras de qualidade de publicação em uma variedade de formatos impressos e ambientes interativos entre plataformas. Matplotlib pode ser usado em scripts Python, nos shells do Python e do IPython, no notebook Jupyter, nos servidores de aplicativos da web e em quatro kits de ferramentas de interface gráfica do usuário. &lt;strong>Matplotlib tenta tornar as coisas fáceis simples e as coisas difíceis possíveis&lt;/strong>. Você pode gerar gráficos, histogramas, espectros de potência, gráficos de barras, gráficos de erros, diagramas de dispersão, etc., com apenas algumas linhas de código.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-python"># As primeiras linhas de código tratam de importar ambas bibliotecas
import pandas as pd
import matplotlib.pyplot as plt
&lt;/code>&lt;/pre>
&lt;p>Se reproduzir esse conteúdo em partes ou em sua totalidade, forneça um link para o material original:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://fschuch.com/blog/2020/04/11/alugar-economizar-e-pagar-a-vista-ou-financiar-um-imovel-um-estudo-de-caso">https://fschuch.com/blog/2020/04/11/alugar-economizar-e-pagar-a-vista-ou-financiar-um-imovel-um-estudo-de-caso&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>E por favor, apoie os nossos autores &lt;a href="https://twitter.com/fschuch" target="_blank" rel="noopener">@fschuch&lt;/a> e &lt;a href="https://twitter.com/mathiazst" target="_blank" rel="noopener">@mathiazst&lt;/a>.&lt;/p>
&lt;div class="alert alert-warning">
&lt;div>
Essa não é uma recomendação de compra. Lucros passados não são garantia de lucros futuros. Esse é um estudo de cenários didáticos e hipotéticos. Os autores se eximem completamente de qualquer responsabilidade sobre o uso, interpretação e consequências do uso direto ou indireto de qualquer informação contida nesse material.
&lt;/div>
&lt;/div>
&lt;h3 id="execute-online">Execute Online&lt;/h3>
&lt;p>Você pode executar esse notebook em seu próprio navegador (nenhuma instalação é necessária), existem duas opções para isso:&lt;/p>
&lt;p>&lt;a href="https://colab.research.google.com/github/fschuch/fschuch.com/blob/master/content/post/2020-matematica-financeira-estudo-de-caso-imovel/Notebook.ipynb" target="_blank" rel="noopener">&lt;img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab">&lt;/a>&lt;/p>
&lt;ul>
&lt;li>O login em uma conta Google pode ser necessário, modifique os blocos de código para os valores que você desejar, na barra de menu superior, procure por &lt;code>Runtime &amp;gt; Run All&lt;/code>;&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://mybinder.org/v2/gh/fschuch/fschuch.com/master?urlpath=lab/tree/content/post/2020-matematica-financeira-estudo-de-caso-imovel/Notebook.ipynb" target="_blank" rel="noopener">&lt;img src="https://binder.pangeo.io/badge_logo.svg" alt="Binder">&lt;/a>&lt;/p>
&lt;ul>
&lt;li>Aguarde enquanto o sistema é preparado (isso pode levar algum tempo), modifique os blocos de código para os valores que você desejar, na barra de menu superior, procure por &lt;code>Cell &amp;gt; Run All&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>Pronto! Interprete os novos resultados obtidos.&lt;/p>
&lt;!--adsense-->
&lt;h2 id="sistemas-de-amortização">Sistemas de Amortização&lt;/h2>
&lt;p>Quando falamos em sistemas de pagamento, ou sistema de amortização, existem quatro parâmetros fundamentais:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Tempo total \(N\);&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Taxa de juros \(i\);&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Saldo devedor inicial \(SD_0\);&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Valor da parcela, que por sua vez é subdividido em:&lt;/p>
&lt;ul>
&lt;li>Amortização, valor que efetivamente abate parte do saldo devedor;&lt;/li>
&lt;li>Juros, valor pago como remuneração ao financiador,&lt;/li>
&lt;/ul>
&lt;p>onde observa-se que:
\[ \text{Amortização} = \text{Parcela} - \text{Juros}. \]&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Pode-se citar pelo menos dois modelos clássicos que tratam dessa relação:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Sistema de Amortização Constante (SAC)&lt;/strong>: Como o próprio nome sugere, a amortização é constante ao longo de todo o tempo:
$$\text{Amortização}_n = \dfrac{SD_0}{N}$$
Os juros são obtidos ao multiplicar a taxa de juros pelo saldo devedor do período anterior:
$$\text{Juros}_n = i \times SD _{n-1}$$
E como vimos, a parcela é a soma dos dois anteriores:
$$\text{Parcela}_n = \text{Juros}_n + \text{Amortização}_n.$$
Note que nesse sistema, o saldo devedor decresce linearmente, além disso, as prestações diminuem gradualmente com o passar do tempo.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Outra opção é a &lt;strong>Tabela Price&lt;/strong>, ou sistema francês de amortização. Aqui, o valor das parcelas é constante no tempo, e obtido por meio de equação:
$$\text{Parcela} = SD_0 \dfrac{i}{1-(1+i)^{-n}}.$$
Os juros são novamente obtidos por:
$$\text{Juros}_n = i \times SD _{n-1}.$$
E por fim obtemos o valor da amortização de cada parcela como:
$$\text{Amortização}_n = \text{Parcela}_n - \text{Juros}_n.$$&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Tendo tudo isso em vista, podemos construir uma rotina em Python que nos retorne um &lt;code>DataFrame&lt;/code> em Pandas, que nada mais é do que uma tabela. Ele inclui os valores obtidos para juros, amortização, parcela e saldo devedor para cada período &lt;code>n&lt;/code>, em função da escolha do sistema de pagamento (SAC ou Price), da taxa de juros &lt;code>i&lt;/code>, do número de períodos de tempo &lt;code>N&lt;/code> e do saldo devedor inicial &lt;code>SD0&lt;/code>. Segue a função:&lt;/p>
&lt;pre>&lt;code class="language-python">def sistema_pagamento(sis,i,N,SD0):
'''
Calcula os juros, amortização, valor das
parcelas e saldo devedor em função do
sistema de amortização escolhido
Args:
sis (str): Sistema de amortização
(SAC ou Price)
i (float): Taxa de juros
N (int): Períodos de tempo
SD0 (float): Saldo devedor inicial
Returns:
df: DataFrame com as colunas juros,
amortização, valor das parcelas
e saldo devedor
'''
df = pd.DataFrame(columns=['Juros',
'Amortização',
'Parcela',
'Saldo Devedor'],
index=range(N+1)
)
df['Saldo Devedor'][0] = SD0
if sis.lower() == 'sac':
df['Amortização'][1:] = SD0/N
for n in df.index[1:]:
df['Juros'][n] = round(df['Saldo Devedor'][n-1]*i,2)
df['Parcela'][n] = df['Juros'][n]+df['Amortização'][n]
df['Saldo Devedor'][n] = df['Saldo Devedor'][n-1] - df['Amortização'][n]
elif sis.lower() == 'price':
df['Parcela'][1:] = round(SD0*(i)/(1-(1+i)**(-N)),2)
for n in df.index[1:]:
df['Juros'][n] = round(df['Saldo Devedor'][n-1]*i,2)
df['Amortização'][n] = df['Parcela'][n] - df['Juros'][n]
df['Saldo Devedor'][n] = df['Saldo Devedor'][n-1] - df['Amortização'][n]
else:
print('Valor inválido para sis, tente novamente com sac ou price')
# Aqui ajustamos a última parcela caso tenha valor residual devido ao arredondamento
df['Parcela'][N] += df['Saldo Devedor'][N]
df['Saldo Devedor'][N] -= df['Saldo Devedor'][N]
return df
&lt;/code>&lt;/pre>
&lt;p>Agora podemos ver um exemplo da função em ação para ambos os sistemas de pagamento, para um taxa de juros de 5%, 4 períodos de tempo e saldo devedor inicial de R$1.000:&lt;/p>
&lt;pre>&lt;code class="language-python">sistema_pagamento('sac',0.05,4,1000)
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:right">&lt;/th>
&lt;th style="text-align:right">Juros&lt;/th>
&lt;th style="text-align:right">Amortização&lt;/th>
&lt;th style="text-align:right">Parcela&lt;/th>
&lt;th style="text-align:right">Saldo Devedor&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:right">0&lt;/td>
&lt;td style="text-align:right">nan&lt;/td>
&lt;td style="text-align:right">nan&lt;/td>
&lt;td style="text-align:right">nan&lt;/td>
&lt;td style="text-align:right">1000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">1&lt;/td>
&lt;td style="text-align:right">50&lt;/td>
&lt;td style="text-align:right">250&lt;/td>
&lt;td style="text-align:right">300&lt;/td>
&lt;td style="text-align:right">750&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">2&lt;/td>
&lt;td style="text-align:right">37.5&lt;/td>
&lt;td style="text-align:right">250&lt;/td>
&lt;td style="text-align:right">287.5&lt;/td>
&lt;td style="text-align:right">500&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">3&lt;/td>
&lt;td style="text-align:right">25&lt;/td>
&lt;td style="text-align:right">250&lt;/td>
&lt;td style="text-align:right">275&lt;/td>
&lt;td style="text-align:right">250&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">4&lt;/td>
&lt;td style="text-align:right">12.5&lt;/td>
&lt;td style="text-align:right">250&lt;/td>
&lt;td style="text-align:right">262.5&lt;/td>
&lt;td style="text-align:right">0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Note na tabela acima algumas posições marcadas com &lt;code>NaN&lt;/code>, abreviação para não um número (do inglês para &lt;em>Not a Number&lt;/em>). Eles ocorreram no nosso exemplo para o tempo 0, onde valores não foram informados para algumas colunas. O &lt;code>NaN&lt;/code> não é necessariamente um problema, a biblioteca Pandas é justamente capaz de lidar com dados faltantes (mais detalhes &lt;a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/missing_data.html" target="_blank" rel="noopener">aqui&lt;/a>). Perceba que essas células podem ser definidos para qualquer valor desejado com o método &lt;code>fillna()&lt;/code>, vamos utiliza-lo no segundo exemplo:&lt;/p>
&lt;pre>&lt;code class="language-python">sistema_pagamento('price',0.05,4,1000).fillna(0)
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:right">&lt;/th>
&lt;th style="text-align:right">Juros&lt;/th>
&lt;th style="text-align:right">Amortização&lt;/th>
&lt;th style="text-align:right">Parcela&lt;/th>
&lt;th style="text-align:right">Saldo Devedor&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:right">0&lt;/td>
&lt;td style="text-align:right">0&lt;/td>
&lt;td style="text-align:right">0&lt;/td>
&lt;td style="text-align:right">0&lt;/td>
&lt;td style="text-align:right">1000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">1&lt;/td>
&lt;td style="text-align:right">50&lt;/td>
&lt;td style="text-align:right">232.01&lt;/td>
&lt;td style="text-align:right">282.01&lt;/td>
&lt;td style="text-align:right">767.99&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">2&lt;/td>
&lt;td style="text-align:right">38.4&lt;/td>
&lt;td style="text-align:right">243.61&lt;/td>
&lt;td style="text-align:right">282.01&lt;/td>
&lt;td style="text-align:right">524.38&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">3&lt;/td>
&lt;td style="text-align:right">26.22&lt;/td>
&lt;td style="text-align:right">255.79&lt;/td>
&lt;td style="text-align:right">282.01&lt;/td>
&lt;td style="text-align:right">268.59&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">4&lt;/td>
&lt;td style="text-align:right">13.43&lt;/td>
&lt;td style="text-align:right">268.58&lt;/td>
&lt;td style="text-align:right">282.02&lt;/td>
&lt;td style="text-align:right">0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Uma das vantagens de se trabalhar com dados tabulares é que eles podem ser facilmente transformados em gráfico, veja como fazemos isso com apenas algumas linhas de código:&lt;/p>
&lt;pre>&lt;code class="language-python">fig, (ax1, ax2) = plt.subplots(nrows=2,
ncols=1,
sharex=True,
sharey=True)
sistema_pagamento('sac',0.05,30,1000).plot(ax=ax1,title='Sistema SAC')
sistema_pagamento('price',0.05,30,1000).plot(ax=ax2,title='Tabela Price')
ax2.set_xlabel('Tempo')
ax1.set_ylabel('Valor - R$')
ax2.set_ylabel('Valor - R$');
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="./Notebook_17_0.png" alt="png">&lt;/p>
&lt;p>Note na figura acima todos os comentários que fizemos anteriormente sobre ambas as formas de pagamento.&lt;/p>
&lt;h2 id="cenários">Cenários&lt;/h2>
&lt;p>Aqui estabelecemos os parâmetros de cálculo que serão empregados nos diferentes cenários. São eles:&lt;/p>
&lt;ul>
&lt;li>Valor do imóvel &lt;code>valor_do_imovel&lt;/code>;&lt;/li>
&lt;li>Valor da entrada &lt;code>entrada&lt;/code>;&lt;/li>
&lt;li>Taxa de juros anual para o financiamento &lt;code>taxa_financeamento_anual&lt;/code>;&lt;/li>
&lt;li>Taxa anual de aluguel &lt;code>taxa_aluguel_anual&lt;/code>: Fração do preço total do imóvel que seria paga como aluguel em um ano;&lt;/li>
&lt;li>Rendimento anual esperado caso os aportes sejam investidos &lt;code>rendimento_investimentos_anual&lt;/code>;&lt;/li>
&lt;li>Quantos anos são esperados para o pagamento &lt;code>tempo_anos&lt;/code>;&lt;/li>
&lt;li>Sistema de amortização &lt;code>sistema&lt;/code> (SAC ou Price).&lt;/li>
&lt;/ul>
&lt;p>Além disso, assume-se que nestes exemplos, todos os parâmetros mantenham-se constantes ao longo do tempo, o que certamente não ocorre em situações reais.&lt;/p>
&lt;pre>&lt;code class="language-python">valor_do_imovel = 500000.00
entrada = 100000.00
taxa_financeamento_anual = 0.0942
taxa_aluguel_anual = 0.04
rendimento_investimentos_anual = 0.08
tempo_anos = 30
sistema = 'SAC'
#sistema = 'PRICE'
&lt;/code>&lt;/pre>
&lt;p>Agora obtemos a taxa de juros mensal correspondente aos valores anualizados que utilizamos como entrada. Lembre-se que:&lt;/p>
&lt;p>$$
i_{\text{mensal}} = (1+ i_{\text{anual}})^\frac{1}{12}-1,
$$&lt;/p>
&lt;p>de maneira que podemos escrever a seguinte função:&lt;/p>
&lt;pre>&lt;code class="language-python">def taxa_aa_para_am(i):
'''
Função recebe uma taxa de juros anual
e retorna a taxa mensal equivalente.
'''
return (1.+i)**(1./12.)-1.
&lt;/code>&lt;/pre>
&lt;p>No seguinte bloco obtemos a valor a ser financiado como o valor do imóvel menos o valor da entrada, além disso, convertemos as taxas para termos mensais, assim como o tempo:&lt;/p>
&lt;pre>&lt;code class="language-python">valor_do_financiamento = valor_do_imovel - entrada
taxa_financeamento = taxa_aa_para_am(taxa_financeamento_anual)
taxa_aluguel = taxa_aa_para_am(taxa_aluguel_anual)
rendimento_investimentos = taxa_aa_para_am(rendimento_investimentos_anual)
tempo = tempo_anos * 12
&lt;/code>&lt;/pre>
&lt;h3 id="financiar">Financiar&lt;/h3>
&lt;p>O primeiro cenário consiste em financiar um imóvel, e para tanto basta aplicarmos a função do sistema de pagamentos que construimos na etapa inicial desse estudo:&lt;/p>
&lt;pre>&lt;code class="language-python">financiar = sistema_pagamento(
sistema,
taxa_financeamento,
tempo,
valor_do_financiamento
)
&lt;/code>&lt;/pre>
&lt;p>Lembre-se que em Python é sempre possível acessar o manual de qualquer função, inclusive da que acabamos de criar, com o comando:&lt;/p>
&lt;pre>&lt;code class="language-python">help(sistema_pagamento)
&lt;/code>&lt;/pre>
&lt;p>Para fins comparativos, vamos estabelecer a evolução temporal do &lt;code>Patrimônio - Imóvel&lt;/code> como a soma acumulativa dos valores de amortização (valor da parcela que efetivamente abate o saldo devedor) e da entrada, enquanto &lt;code>Custo - Juros&lt;/code> será a soma acumulativa dos valores de juros (valor da parcela que remunera a instituição financiadora).&lt;/p>
&lt;pre>&lt;code class="language-python">financiar['Patrimônio - Imóvel'] = financiar['Amortização'].cumsum() + entrada
financiar['Custo - Juros'] = financiar['Juros'].cumsum()
&lt;/code>&lt;/pre>
&lt;p>Podemos visualizar todos os elementos da nossa tabela:&lt;/p>
&lt;pre>&lt;code class="language-python">financiar
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:right">&lt;/th>
&lt;th style="text-align:right">Juros&lt;/th>
&lt;th style="text-align:right">Amortização&lt;/th>
&lt;th style="text-align:right">Parcela&lt;/th>
&lt;th style="text-align:right">Saldo Devedor&lt;/th>
&lt;th style="text-align:right">Patrimônio - Imóvel&lt;/th>
&lt;th style="text-align:right">Custo - Juros&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:right">0&lt;/td>
&lt;td style="text-align:right">nan&lt;/td>
&lt;td style="text-align:right">nan&lt;/td>
&lt;td style="text-align:right">nan&lt;/td>
&lt;td style="text-align:right">400000&lt;/td>
&lt;td style="text-align:right">nan&lt;/td>
&lt;td style="text-align:right">nan&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">1&lt;/td>
&lt;td style="text-align:right">3012.07&lt;/td>
&lt;td style="text-align:right">1111.11&lt;/td>
&lt;td style="text-align:right">4123.18&lt;/td>
&lt;td style="text-align:right">398889&lt;/td>
&lt;td style="text-align:right">101111&lt;/td>
&lt;td style="text-align:right">3012.07&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">2&lt;/td>
&lt;td style="text-align:right">3003.7&lt;/td>
&lt;td style="text-align:right">1111.11&lt;/td>
&lt;td style="text-align:right">4114.81&lt;/td>
&lt;td style="text-align:right">397778&lt;/td>
&lt;td style="text-align:right">102222&lt;/td>
&lt;td style="text-align:right">6015.77&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">3&lt;/td>
&lt;td style="text-align:right">2995.33&lt;/td>
&lt;td style="text-align:right">1111.11&lt;/td>
&lt;td style="text-align:right">4106.44&lt;/td>
&lt;td style="text-align:right">396667&lt;/td>
&lt;td style="text-align:right">103333&lt;/td>
&lt;td style="text-align:right">9011.1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">4&lt;/td>
&lt;td style="text-align:right">2986.97&lt;/td>
&lt;td style="text-align:right">1111.11&lt;/td>
&lt;td style="text-align:right">4098.08&lt;/td>
&lt;td style="text-align:right">395556&lt;/td>
&lt;td style="text-align:right">104444&lt;/td>
&lt;td style="text-align:right">11998.1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">&amp;hellip;&lt;/td>
&lt;td style="text-align:right">&amp;hellip;&lt;/td>
&lt;td style="text-align:right">&amp;hellip;&lt;/td>
&lt;td style="text-align:right">&amp;hellip;&lt;/td>
&lt;td style="text-align:right">&amp;hellip;&lt;/td>
&lt;td style="text-align:right">&amp;hellip;&lt;/td>
&lt;td style="text-align:right">&amp;hellip;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">356&lt;/td>
&lt;td style="text-align:right">41.83&lt;/td>
&lt;td style="text-align:right">1111.11&lt;/td>
&lt;td style="text-align:right">1152.94&lt;/td>
&lt;td style="text-align:right">4444.44&lt;/td>
&lt;td style="text-align:right">495556&lt;/td>
&lt;td style="text-align:right">543595&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">357&lt;/td>
&lt;td style="text-align:right">33.47&lt;/td>
&lt;td style="text-align:right">1111.11&lt;/td>
&lt;td style="text-align:right">1144.58&lt;/td>
&lt;td style="text-align:right">3333.33&lt;/td>
&lt;td style="text-align:right">496667&lt;/td>
&lt;td style="text-align:right">543628&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">358&lt;/td>
&lt;td style="text-align:right">25.1&lt;/td>
&lt;td style="text-align:right">1111.11&lt;/td>
&lt;td style="text-align:right">1136.21&lt;/td>
&lt;td style="text-align:right">2222.22&lt;/td>
&lt;td style="text-align:right">497778&lt;/td>
&lt;td style="text-align:right">543653&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">359&lt;/td>
&lt;td style="text-align:right">16.73&lt;/td>
&lt;td style="text-align:right">1111.11&lt;/td>
&lt;td style="text-align:right">1127.84&lt;/td>
&lt;td style="text-align:right">1111.11&lt;/td>
&lt;td style="text-align:right">498889&lt;/td>
&lt;td style="text-align:right">543670&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:right">360&lt;/td>
&lt;td style="text-align:right">8.37&lt;/td>
&lt;td style="text-align:right">1111.11&lt;/td>
&lt;td style="text-align:right">1119.48&lt;/td>
&lt;td style="text-align:right">0&lt;/td>
&lt;td style="text-align:right">500000&lt;/td>
&lt;td style="text-align:right">543678&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>361 rows × 6 columns&lt;/p>
&lt;p>Ou facilmente graficar os resultados para o primeiro cenário:&lt;/p>
&lt;pre>&lt;code class="language-python">financiar[['Patrimônio - Imóvel',
'Custo - Juros']
].plot.area(title='Financiar')
plt.xlabel('Tempo (meses)')
plt.ylabel('Valor (R$)')
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="./Notebook_34_0.png" alt="png">&lt;/p>
&lt;p>Veja o que dizem os números:&lt;/p>
&lt;blockquote>
&lt;p>Ao longo de 360 meses, o montante total de R$1.043.678,18 foi desembolsado, sendo:&lt;br>&lt;/p>
&lt;ul>
&lt;li>R$543.678,18 para a instituição financeira (52,09% do total);&lt;br>&lt;/li>
&lt;li>R$500.000,0 foram aportados no imóvel (47,91% do total).&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="alugar-e-aportar-mensalmente">Alugar e Aportar Mensalmente&lt;/h3>
&lt;p>O segundo cenário avalia não comprar, mas sim alugar o imóvel pelo tempo estipulado. Entretanto, considera-se que todos os valores que seriam gastos com o financiamento no caso anterior serão convertidos em aportes em aplicações financeiras.&lt;/p>
&lt;pre>&lt;code class="language-python"># Inicializamos um DataFrame vazio
alugar = pd.DataFrame(index=range(tempo+1))
# Calculamos o valor do aluguel
aluguel = round((valor_do_imovel)*taxa_aluguel,2)
alugar['Aluguel'] = aluguel
# Aluguel no tempo zero é igual a zero
alugar['Aluguel'][0] = 0.0
# Aqui calculamos o custo com aluguel como o somatório
# de todos os valores pagos
alugar['Custo - Aluguel'] = alugar['Aluguel'].cumsum()
# O aporte em aplicações financeiras se da pela diferença
# entre o que seria pago de financiamento no exemplo anterior
# e o valor do aluguel do imóvel
alugar['Aportes'] = financiar['Parcela'] - aluguel
# E o aporte inicial é o valor que estaria disponível como entrada
alugar['Aportes'][0] = entrada
&lt;/code>&lt;/pre>
&lt;p>Nesse exemplo faremos uma separação do &lt;code>Patrimônio&lt;/code> em duas partes, a fração que é proveniente dos aportes como &lt;code>Patrimônio - Principal&lt;/code>, enquanto a parte proveniente do rendimento dos juros será denominada &lt;code>Patrimônio - Rendimentos&lt;/code>, que podem ser calculados como segue:&lt;/p>
&lt;pre>&lt;code class="language-python"># Aqui a variável é basicamente inicializada
alugar['Patrimônio'] = alugar['Aportes']
# O patrimônio é realmente calculado neste laço
for n in alugar.index[1:]:
alugar['Patrimônio'][n] = alugar['Aportes'][n] + alugar['Patrimônio'][n-1] * (1. + rendimento_investimentos)
# Por fim, a fração Principal é tida como o somatório de todos os aportes
alugar['Patrimônio - Principal'] = alugar['Aportes'].cumsum()
# E os rendimentos são obtidos pela seguinte subtração
alugar['Patrimônio - Rendimentos'] = alugar['Patrimônio'] - alugar['Patrimônio - Principal']
&lt;/code>&lt;/pre>
&lt;p>Feito todos os cálculos, podemos analisar os resultados&lt;/p>
&lt;pre>&lt;code class="language-python">alugar[['Patrimônio - Principal',
'Patrimônio - Rendimentos',
'Custo - Aluguel']
].plot.area(title='Alugar e Aportar Mensalmente')
plt.xlabel('Tempo (meses)')
plt.ylabel('Valor (R$)')
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="./Notebook_43_0.png" alt="png">&lt;/p>
&lt;p>Veja o que dizem os números:&lt;/p>
&lt;blockquote>
&lt;p>Ao longo de 360 meses, temos:&lt;br>&lt;/p>
&lt;ul>
&lt;li>R$589.273,20 foram desembolsados com aluguel;&lt;br>&lt;/li>
&lt;li>O montante total em investimentos é de R$3.144.815,24, sendo:&lt;br>
&lt;ul>
&lt;li>R$454.404,98 proveniente dos aportes (14,45% do total);&lt;/li>
&lt;li>R$2.690.410,26 dos rendimentos (85,55% do total).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="economizar-e-comprar-à-vista">Economizar e Comprar à Vista&lt;/h3>
&lt;p>O terceiro cenário considera a hipótese de alugar um imóvel e investir a diferença que haveria para um possível financiamento, assim como no caso anterior do aluguel. A diferença é que aqui o imóvel será comprado quando os investimentos atingirem o valor necessário. Nesse momento, o pagamento do aluguel será encerrado e os valores serão convertidos em mais aporte.&lt;/p>
&lt;p>O patrimônio será composto agora de três partes, além da fração que é proveniente dos aportes como &lt;code>Patrimônio - Principal&lt;/code> e da parte proveniente do rendimento dos juros, denominada &lt;code>Patrimônio - Rendimentos&lt;/code>, teremos o &lt;code>Patrimônio - Imóvel&lt;/code>.&lt;/p>
&lt;p>Veja o cálculo:&lt;/p>
&lt;pre>&lt;code class="language-python"># A parte inicial desse cenário é igual ao anterior,
# então iniciamos copiando os resultados
comprar = alugar.copy()
comprar['Patrimônio - Imóvel'] = 0.0
# A diferença é que o imóvel será comprado quando
# se atingir o saldo disponível, obtemos essa
# valor da planilha com o seguinte comando
tcompra = comprar[comprar['Patrimônio']&amp;gt;=valor_do_imovel].first_valid_index()
# Escrevemos na tela para conferência
print(f'O imóvel será comprado no mês {tcompra}')
# Nesse instante compramos o imóvel
comprar['Patrimônio - Imóvel'][tcompra::] += valor_do_imovel
# E descontamos o valor da compra do
# montante que estava investido
comprar['Patrimônio'][tcompra::] -= valor_do_imovel
comprar['Patrimônio - Principal'][tcompra] -= valor_do_imovel - comprar['Patrimônio - Rendimentos'][tcompra]
comprar['Patrimônio - Rendimentos'][tcompra] = 0.0
# Então redirecionamos todo o valor que seria gasto
# com aluguel a partir daqui para mais aportes
comprar['Aportes'][tcompra::] += comprar['Aluguel'][tcompra::]
# Zeramos a atualizamos o cálculo com custo de aluguel
comprar['Aluguel'][tcompra::] = 0.0
comprar['Custo - Aluguel'] = comprar['Aluguel'].cumsum()
# Por fim, calcula-se a evolução do patrimônio a
# partir da data da compra do imóvel
for n in alugar.index[tcompra+1:]:
comprar['Patrimônio - Principal'][n] = comprar['Patrimônio - Principal'][n-1] + comprar['Aportes'][n]
comprar['Patrimônio - Rendimentos'][n] = comprar['Patrimônio'][n-1] * rendimento_investimentos + comprar['Patrimônio - Rendimentos'][n-1]
comprar['Patrimônio'][n] = comprar['Patrimônio - Principal'][n] + comprar['Patrimônio - Rendimentos'][n]
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>O imóvel será comprado no mês 103.&lt;/p>
&lt;/blockquote>
&lt;p>E produzimos a figura do caso:&lt;/p>
&lt;pre>&lt;code class="language-python">comprar[['Patrimônio - Imóvel',
'Patrimônio - Principal',
'Patrimônio - Rendimentos',
'Custo - Aluguel']
].plot.area(title='Economizar e Comprar à Vista')
plt.xlabel('Tempo (meses)')
plt.ylabel('Valor (R$)')
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="./Notebook_51_0.png" alt="png">&lt;/p>
&lt;p>Veja o que dizem os números:&lt;/p>
&lt;blockquote>
&lt;p>Ao longo de 360 meses:&lt;br>&lt;/p>
&lt;ul>
&lt;li>R$166.960,74 foram desembolsados com 103 meses de aluguel;&lt;br>&lt;/li>
&lt;li>O montante total em investimentos foi de R$2.113.852,73, sendo:&lt;br>
&lt;ul>
&lt;li>R$562.981,64 proveniente dos aportes (26,63% do total);&lt;br>&lt;/li>
&lt;li>R$1.050.871,09 dos rendimentos (49,71% do total);&lt;br>&lt;/li>
&lt;li>Além de R$500.000,00 do imóvel (23,65% do total).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="síntese-dos-resultados">Síntese dos Resultados&lt;/h2>
&lt;p>Para sintetizar tudo o que vimos até aqui, criaremos uma tabela auxiliar apenas com os dados observados ao final do período de estudos, e isso é feito facilmente em um DataFrame com o comando &lt;code>.tail(1)&lt;/code>:&lt;/p>
&lt;pre>&lt;code class="language-python"># Criamos um DataFrame vazio
summary = pd.DataFrame()
# Adicionamos os valores obtidos na tempo final de cada um dos cenários
summary = summary.append(alugar.tail(1), ignore_index=True, sort=False)
summary = summary.append(comprar.tail(1), ignore_index=True, sort=False)
summary = summary.append(financiar.tail(1), ignore_index=True, sort=False)
# Vamos eliminar as colunas da tabela que não nos interessam
summary.drop(['Aluguel', 'Aportes', 'Patrimônio', 'Juros',
'Amortização', 'Parcela', 'Saldo Devedor'], axis=1, inplace=True)
# E renomear as linhas de acordo com cada caso
summary.index = ['Alugar', 'Comprar à Vista', 'Financiar']
# Por fim mostramos na tela
summary.fillna(0)
&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">&lt;/th>
&lt;th style="text-align:right">Custo - Aluguel&lt;/th>
&lt;th style="text-align:right">Patrimônio - Principal&lt;/th>
&lt;th style="text-align:right">Patrimônio - Rendimentos&lt;/th>
&lt;th style="text-align:right">Patrimônio - Imóvel&lt;/th>
&lt;th style="text-align:right">Custo - Juros&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">Alugar&lt;/td>
&lt;td style="text-align:right">589273&lt;/td>
&lt;td style="text-align:right">454405&lt;/td>
&lt;td style="text-align:right">2.69041e+06&lt;/td>
&lt;td style="text-align:right">0&lt;/td>
&lt;td style="text-align:right">0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Comprar à Vista&lt;/td>
&lt;td style="text-align:right">166961&lt;/td>
&lt;td style="text-align:right">562982&lt;/td>
&lt;td style="text-align:right">1.05087e+06&lt;/td>
&lt;td style="text-align:right">500000&lt;/td>
&lt;td style="text-align:right">0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Financiar&lt;/td>
&lt;td style="text-align:right">0&lt;/td>
&lt;td style="text-align:right">0&lt;/td>
&lt;td style="text-align:right">0&lt;/td>
&lt;td style="text-align:right">500000&lt;/td>
&lt;td style="text-align:right">543678&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Por fim, apresentamos a figura:&lt;/p>
&lt;pre>&lt;code class="language-python">summary[['Patrimônio - Imóvel',
'Patrimônio - Principal',
'Patrimônio - Rendimentos',
'Custo - Aluguel',
'Custo - Juros']
].plot.barh(stacked=True)
plt.title('Estudo de caso: Financiar, economizar e pagar \n à vista ou alugar um imóvel?')
plt.xlabel('Valor (R$)')
plt.locator_params(axis='x', nbins=5)
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="./Notebook_58_0.png" alt="png">&lt;/p>
&lt;!--adsense-->
&lt;h1 id="conclusão">Conclusão&lt;/h1>
&lt;p>Nesse estudo de caso buscamos identificar as possíveis diferenças nos resultados de financiar quatro quintos de um imóvel, alugar um imóvel para morar e investir o montante que seria desembolsado com a compra, e pagar aluguel enquanto poupa o dinheiro para comprá-lo à vista. Para quaisquer exercícios deste tipo, o valor da taxa de juros é sempre o principal determinante.
Vamos considerar os juros como os valores pagos pela posse do dinheiro, onde você os paga quando é um agente deficitário – tem menos dinheiro do que necessita e precisa tomar emprestado – e os recebe quando é um agente superavitário – tem mais dinheiro do que precisa e investe o que sobra -, e que tem sua taxa definida pelas escolhas intertemporais dos indivíduos, as quais acabam por determinar sua oferta e demanda de equilíbrio.
Para fins de simplificação e comparação dos três cenários em questão, mantivemos constantes as receitas e despesas das famílias, assim como a taxa de juros do financiamento em 9,42% a.a., do aluguel em 4% a.a. e dos rendimentos financeiros em 8% a.a.
Os resultados mostram que ao final do período considerado, caso você não atribua valor – tenha prazer - ao fato de se considerar o dono do imóvel, os benefícios pecuniários serão muito maiores se for pago aluguel e investido os valores que seriam gastos com a compra do imóvel. Se por algum motivo essa não for uma alternativa, é mais vantajoso poupar o dinheiro enquanto paga o aluguel para efetuar a compra do imóvel à vista, ao final dos primeiros 29% do período.&lt;br>&lt;/p></description></item><item><title>Métodos Numéricos Aplicados à Transferência de Calor</title><link>https://www.fschuch.com/talk/metodos-numericos-aplicados-a-transferencia-de-calor/</link><pubDate>Wed, 09 Oct 2019 19:30:00 -0300</pubDate><guid>https://www.fschuch.com/talk/metodos-numericos-aplicados-a-transferencia-de-calor/</guid><description/></item><item><title>Python: Introdução e Aplicações da Linguagem de Programação em Engenharia</title><link>https://www.fschuch.com/talk/python-introducao-e-aplicacoes-da-linguagem-de-programacao-em-engenharia/</link><pubDate>Tue, 16 Jul 2019 14:00:00 -0300</pubDate><guid>https://www.fschuch.com/talk/python-introducao-e-aplicacoes-da-linguagem-de-programacao-em-engenharia/</guid><description/></item></channel></rss>